{% extends 'base.html' %}

{% block title %}The Digger - Find DJ Tracklists{% endblock %}

{% block content %}
<div class="search-section">
    <form action="{{ url_for('search') }}" method="get" class="search-form">
        <input type="text" name="artist_name" value="{{ artist_name if artist_name else '' }}" placeholder="Enter artist name (e.g., Ben UFO)" required>
        <button type="submit">Find Tracklists</button>
    </form>
    
    <!-- Progress bar added here -->
    <div class="progress-bar-container" style="display: none;">
        <div class="progress-bar">
            <div class="progress-bar-fill"></div>
        </div>
        <p class="progress-status">Searching for tracklists...</p>
    </div>
    
    <div class="search-options">
        <span class="search-options-text">Or get a PDF directly:</span>
        <form action="{{ url_for('direct_pdf_download') }}" method="get" class="direct-pdf-form">
            <input type="text" name="artist_name" placeholder="Enter artist name" required>
            <button type="submit" class="pdf-button">
                <svg class="pdf-icon" viewBox="0 0 24 24" width="18" height="18">
                    <path d="M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8.5 7.5c0 .83-.67 1.5-1.5 1.5H9v2H7.5V7H10c.83 0 1.5.67 1.5 1.5v1zm5 2c0 .83-.67 1.5-1.5 1.5h-2.5V7H15c.83 0 1.5.67 1.5 1.5v3zm4-3H19v1h1.5V11H19v2h-1.5V7h3v1.5zM9 9.5h1v-1H9v1zM4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm10 5.5h1v-3h-1v3z" fill="currentColor"/>
                </svg>
                Download PDF
            </button>
        </form>
        <p class="direct-pdf-hint">Skip loading the UI for faster results with large catalogs</p>
    </div>
</div>

{% if error %}
<div class="error">
    {{ error }}
</div>
{% endif %}

{% if tracks %}
<div class="results-section">
    <h2>Tracklists for {{ artist_name }}</h2>
    
    {% set total_tracks = 0 %}
    {% set mixes_with_tracklists = 0 %}
    {% for mix in tracks %}
        {% if mix.has_tracklist %}
            {% set mixes_with_tracklists = mixes_with_tracklists + 1 %}
            {% set total_tracks = total_tracks + mix.tracks|length %}
        {% endif %}
    {% endfor %}
    
    <p>Found {{ total_tracks }} tracks across {{ mixes_with_tracklists }} mixes with tracklists ({{ tracks|length }} total mixes)</p>
    
    <div class="results-actions">
        <a href="{{ url_for('download_tracklists_pdf', artist_name=artist_name) }}" class="download-pdf-btn" title="Download all tracklists as PDF">
            <svg class="pdf-icon" viewBox="0 0 24 24" width="24" height="24">
                <path d="M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8.5 7.5c0 .83-.67 1.5-1.5 1.5H9v2H7.5V7H10c.83 0 1.5.67 1.5 1.5v1zm5 2c0 .83-.67 1.5-1.5 1.5h-2.5V7H15c.83 0 1.5.67 1.5 1.5v3zm4-3H19v1h1.5V11H19v2h-1.5V7h3v1.5zM9 9.5h1v-1H9v1zM4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm10 5.5h1v-3h-1v3z" fill="currentColor"/>
            </svg>
            Download PDF
        </a>
        
        <div class="playback-controls">
            <button id="play-all-btn" class="play-all-button" title="Play all tracks">
                <svg class="play-all-icon" viewBox="0 0 24 24" width="24" height="24">
                    <path d="M8 5v14l11-7z" fill="currentColor"/>
                </svg>
                Play All Tracks
            </button>
            
            <button id="skip-track-btn" class="skip-track-button" title="Skip to next track" disabled>
                <svg class="skip-icon" viewBox="0 0 24 24" width="24" height="24">
                    <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z" fill="currentColor"/>
                </svg>
                Skip
            </button>
        </div>
    </div>
    
    <div class="filters">
        <label>
            <input type="checkbox" id="show-all-mixes" checked>
            Show mixes without tracklists
        </label>
    </div>
    
    <div class="mixes-container">
        {% for mix in tracks %}
        <div class="mix-section {% if not mix.has_tracklist %}mix-no-tracklist{% endif %}">
            <div class="mix-header">
                <h3 class="mix-title">
                    {{ mix.title }}
                    {% if mix.date %}
                    <span class="mix-date">({{ mix.date }})</span>
                    {% endif %}
                </h3>
                
                <div class="mix-badges">
                    {% if mix.has_tracklist %}
                    <span class="tracklist-badge">{{ mix.tracks|length }} tracks</span>
                    {% else %}
                    <span class="no-tracklist-badge">No tracklist available</span>
                    {% endif %}
                </div>
            </div>
            
            <div class="mix-actions">
                {% if mix.url %}
                <a href="{{ mix.url }}" class="mix-link" target="_blank">View on MixesDB</a>
                {% endif %}
            </div>
            
            {% if mix.has_tracklist %}
            <div class="tracklist-container">
                <h4 class="tracklist-header">Tracklist:</h4>
                <ol class="track-list">
                    {% for track in mix.tracks %}
                    <li class="track-item">
                        <div class="track-info">
                            <span class="track-name">{{ track.track }}</span>
                            <button class="play-button" data-track="{{ track.track|urlencode }}" title="Play track">
                                <span class="play-icon">▶</span> Play
                            </button>
                        </div>
                        <!-- Inline player will be inserted here when track is played -->
                        <div class="inline-player-container" style="display: none;">
                            <div class="player-controls">
                                <div class="audio-controls">
                                    <span class="control-btn play-pause-btn">⏸</span>
                                    <span class="time-display">0:00</span>
                                    <a href="#" class="youtube-link" target="_blank" title="View on YouTube">
                                        <svg class="youtube-icon" viewBox="0 0 24 24" width="22" height="22">
                                            <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z" fill="#ff0000"/>
                                        </svg>
                                    </a>
                                </div>
                                <div class="youtube-player-wrapper">
                                    <!-- YouTube player will be inserted here -->
                                </div>
                            </div>
                        </div>
                    </li>
                    {% endfor %}
                </ol>
            </div>
            {% else %}
            <p class="no-tracks-message">No tracklist is available for this mix.</p>
            {% endif %}
        </div>
        {% endfor %}
    </div>
</div>
{% endif %}
{% endblock %}

{% block scripts %}
<script>
// Create script tag for YouTube iframe API programmatically
const tag = document.createElement('script');
tag.src = "https://www.youtube.com/iframe_api";
const firstScriptTag = document.getElementsByTagName('script')[0];
firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

// Main app logic
document.addEventListener('DOMContentLoaded', function() {
    const searchForm = document.querySelector('.search-form');
    const searchInput = searchForm.querySelector('input[name="artist_name"]');
    const progressBarContainer = document.querySelector('.progress-bar-container');
    
    // Focus the input field when the page loads
    searchInput.focus();
    
    // Auto-select all text when input field is clicked
    searchInput.addEventListener('click', function() {
        this.select();
    });

    // Show progress bar when search form is submitted
    searchForm.addEventListener('submit', function(e) {
        // Only show the progress bar if the form is valid
        if (searchForm.checkValidity()) {
            progressBarContainer.style.display = 'block';
            
            // Disable the submit button to prevent multiple submissions
            const submitBtn = searchForm.querySelector('button[type="submit"]');
            submitBtn.disabled = true;
            submitBtn.textContent = 'Searching...';
        }
    });

    // PDF form should also show a loading state
    const directPdfForm = document.querySelector('.direct-pdf-form');
    if (directPdfForm) {
        directPdfForm.addEventListener('submit', function(e) {
            if (directPdfForm.checkValidity()) {
                const pdfBtn = directPdfForm.querySelector('.pdf-button');
                pdfBtn.disabled = true;
                pdfBtn.innerHTML = `
                    <svg class="pdf-icon" viewBox="0 0 24 24" width="18" height="18">
                        <path d="M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8.5 7.5c0 .83-.67 1.5-1.5 1.5H9v2H7.5V7H10c.83 0 1.5.67 1.5 1.5v1zm5 2c0 .83-.67 1.5-1.5 1.5h-2.5V7H15c.83 0 1.5.67 1.5 1.5v3zm4-3H19v1h1.5V11H19v2h-1.5V7h3v1.5zM9 9.5h1v-1H9v1zM4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm10 5.5h1v-3h-1v3z" fill="currentColor"/>
                    </svg>
                    Generating PDF...
                `;
            }
        });
    }

    // Filter checkbox for mixes without tracklists
    const showAllMixesCheckbox = document.getElementById('show-all-mixes');
    if (showAllMixesCheckbox) {
        showAllMixesCheckbox.addEventListener('change', function() {
            const noTracklistMixes = document.querySelectorAll('.mix-no-tracklist');
            noTracklistMixes.forEach(mix => {
                mix.style.display = this.checked ? 'block' : 'none';
            });
        });
    }

    // YouTube player variables
    let currentPlayer = null;
    let currentPlayerContainer = null;
    let youtubeReady = false;
    let updateTimeInterval;
    let activeTrackItem = null;
    let waitingQueue = [];
    
    // Play All tracks functionality
    let trackQueue = [];
    let currentTrackIndex = -1;
    let isPlayingAll = false;
    let switchTrackTimeout = null;
    const TRACK_PLAY_DURATION = 120000; // 2 minutes in milliseconds

    // Initialize YouTube API
    window.onYouTubeIframeAPIReady = function() {
        youtubeReady = true;
        console.log("YouTube API is ready");
        
        // Process any waiting players
        while (waitingQueue.length > 0) {
            const task = waitingQueue.shift();
            task();
        }
    };

    function waitForYouTubeAPI(callback) {
        if (youtubeReady) {
            callback();
        } else {
            console.log("YouTube API not ready, adding to queue");
            waitingQueue.push(callback);
        }
    }

    // Format time in minutes:seconds
    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs < 10 ? '0' + secs : secs}`;
    }

    // Start updating the time display
    function startTimeUpdate(player, timeDisplay) {
        stopTimeUpdate(); // Clear any existing interval
        updateTimeInterval = setInterval(() => {
            if (player) {
                const currentTime = player.getCurrentTime();
                timeDisplay.textContent = formatTime(currentTime);
            }
        }, 1000);
    }

    // Stop updating the time display
    function stopTimeUpdate() {
        if (updateTimeInterval) {
            clearInterval(updateTimeInterval);
        }
    }

    // Handle player state changes
    function onPlayerStateChange(event, playPauseBtn, timeDisplay) {
        console.log("Player state changed:", event.data);
        if (event.data === YT.PlayerState.PLAYING) {
            playPauseBtn.textContent = '⏸';
            startTimeUpdate(event.target, timeDisplay);
            
            // If we're in play all mode and this is a track ending, set up the next track
            if (isPlayingAll && !switchTrackTimeout) {
                switchTrackTimeout = setTimeout(() => {
                    playNextTrack();
                }, TRACK_PLAY_DURATION);
            }
        } else if (event.data === YT.PlayerState.PAUSED) {
            playPauseBtn.textContent = '▶';
            stopTimeUpdate();
            
            // If we're in play all mode and user paused, clear the timeout
            if (isPlayingAll && switchTrackTimeout) {
                clearTimeout(switchTrackTimeout);
                switchTrackTimeout = null;
            }
        } else if (event.data === YT.PlayerState.ENDED) {
            playPauseBtn.textContent = '▶';
            stopTimeUpdate();
            
            // If we're in play all mode and the video ended, play the next track
            if (isPlayingAll) {
                // Clear any existing timeout since the track ended
                if (switchTrackTimeout) {
                    clearTimeout(switchTrackTimeout);
                    switchTrackTimeout = null;
                }
                
                // Play the next track immediately
                playNextTrack();
            }
        }
    }

    // Create a new YouTube player
    function createPlayer(container, videoId, playPauseBtn, timeDisplay) {
        console.log("Creating player for video ID:", videoId);
        
        // If there's already a player, stop and destroy it
        if (currentPlayer) {
            try {
                currentPlayer.stopVideo();
                currentPlayer.destroy();
            } catch (e) {
                console.error("Error destroying previous player:", e);
            }
            currentPlayer = null;
        }

        // Create a placeholder for the iframe
        const playerPlaceholder = document.createElement('div');
        container.appendChild(playerPlaceholder);

        // Create new player
        try {
            const player = new YT.Player(playerPlaceholder, {
                height: '1',  // Minimal height - we're using it just for audio
                width: '1',   // Minimal width - we're using it just for audio
                videoId: videoId,
                playerVars: {
                    'autoplay': 1,
                    'controls': 0,
                    'disablekb': 1,
                    'fs': 0,
                    'modestbranding': 1,
                    'start': 120,  // Start at 2 minutes (120 seconds)
                    'iv_load_policy': 3
                },
                events: {
                    'onStateChange': (event) => onPlayerStateChange(event, playPauseBtn, timeDisplay),
                    'onReady': (event) => {
                        console.log("Player ready event");
                        timeDisplay.textContent = "0:00"; // Reset time display when player is ready
                        event.target.playVideo();
                    },
                    'onError': (event) => {
                        console.error("Player error:", event.data);
                        
                        // Show error message to user
                        const errorMessages = {
                            2: "Invalid video ID",
                            5: "HTML5 player error",
                            100: "Video not found or removed",
                            101: "Video owner doesn't allow embedded playback",
                            150: "Video owner doesn't allow embedded playback"
                        };
                        
                        const errorMsg = errorMessages[event.data] || "Unknown error playing video";
                        timeDisplay.textContent = "Error";
                        timeDisplay.title = errorMsg;
                        
                        // If in play all mode and there's an error, move to the next track
                        if (isPlayingAll) {
                            setTimeout(() => playNextTrack(), 1000);
                        }
                    }
                }
            });
            return player;
        } catch (e) {
            console.error("Error creating YouTube player:", e);
            
            // If in play all mode and there's an error, move to the next track
            if (isPlayingAll) {
                setTimeout(() => playNextTrack(), 1000);
            }
            
            return null;
        }
    }
    
    // Play All functionality
    const playAllBtn = document.getElementById('play-all-btn');
    const skipTrackBtn = document.getElementById('skip-track-btn');
    
    if (playAllBtn) {
        playAllBtn.addEventListener('click', function() {
            // If already playing, stop the current playback
            if (isPlayingAll) {
                stopPlayAll();
                return;
            }
            
            // Initialize the track queue
            initializeTrackQueue();
            
            // Start playing if we have tracks
            if (trackQueue.length > 0) {
                isPlayingAll = true;
                currentTrackIndex = -1;
                playAllBtn.textContent = "Stop Playback";
                playAllBtn.style.backgroundColor = "#666";
                
                // Enable skip button when playback starts
                if (skipTrackBtn) {
                    skipTrackBtn.disabled = false;
                }
                
                // Begin playback with the first track
                playNextTrack();
            } else {
                alert("No tracks found to play!");
            }
        });
    }
    
    // Skip to next track button
    if (skipTrackBtn) {
        skipTrackBtn.addEventListener('click', function() {
            if (isPlayingAll) {
                // Clear any existing timeout
                if (switchTrackTimeout) {
                    clearTimeout(switchTrackTimeout);
                    switchTrackTimeout = null;
                }
                
                // Skip to the next track
                playNextTrack();
            }
        });
    }
    
    // Initialize the track queue
    function initializeTrackQueue() {
        trackQueue = [];
        
        // Get all playable tracks
        const playButtons = document.querySelectorAll('.play-button');
        playButtons.forEach(button => {
            const trackName = decodeURIComponent(button.getAttribute('data-track'));
            const trackItem = button.closest('.track-item');
            
            trackQueue.push({
                name: trackName,
                element: trackItem,
                button: button
            });
        });
        
        console.log(`Initialized track queue with ${trackQueue.length} tracks`);
    }
    
    // Play the next track in the queue
    function playNextTrack() {
        // Clear any existing timeout
        if (switchTrackTimeout) {
            clearTimeout(switchTrackTimeout);
            switchTrackTimeout = null;
        }
        
        // Remove highlighting from all tracks
        document.querySelectorAll('.track-item.now-playing').forEach(item => {
            item.classList.remove('now-playing');
        });
        
        // Move to the next track
        currentTrackIndex++;
        
        // Check if we've reached the end of the queue
        if (currentTrackIndex >= trackQueue.length) {
            console.log("Reached end of track queue, stopping playback");
            stopPlayAll();
            return;
        }
        
        const track = trackQueue[currentTrackIndex];
        console.log(`Playing track ${currentTrackIndex + 1}/${trackQueue.length}: ${track.name}`);
        
        // Highlight the current track
        track.element.classList.add('now-playing');
        
        // Simulate clicking the play button for this track
        track.button.click();
        
        // Scroll to the current track
        track.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
    
    // Stop playing all tracks
    function stopPlayAll() {
        isPlayingAll = false;
        
        // Reset the play all button
        if (playAllBtn) {
            playAllBtn.textContent = "Play All Tracks";
            playAllBtn.style.backgroundColor = "";
        }
        
        // Disable the skip button
        if (skipTrackBtn) {
            skipTrackBtn.disabled = true;
        }
        
        // Clear any scheduled track change
        if (switchTrackTimeout) {
            clearTimeout(switchTrackTimeout);
            switchTrackTimeout = null;
        }
        
        // Remove highlighting from all tracks
        document.querySelectorAll('.track-item.now-playing').forEach(item => {
            item.classList.remove('now-playing');
        });
        
        // Stop the current player if any
        if (currentPlayer) {
            try {
                currentPlayer.pauseVideo();
            } catch (e) {
                console.error("Error pausing video:", e);
            }
        }
    }

    // Handle play button clicks
    const playButtons = document.querySelectorAll('.play-button');
    playButtons.forEach(button => {
        button.addEventListener('click', function() {
            console.log("Play button clicked");
            
            // Get the track item and details
            const trackItem = this.closest('.track-item');
            const trackName = decodeURIComponent(this.getAttribute('data-track'));
            console.log("Track name:", trackName);
            
            // Show the inline player for this track
            const playerContainer = trackItem.querySelector('.inline-player-container');
            playerContainer.style.display = 'block';
            
            // Set this as the active track
            activeTrackItem = trackItem;
            
            // Get control elements
            const playPauseBtn = playerContainer.querySelector('.play-pause-btn');
            const timeDisplay = playerContainer.querySelector('.time-display');
            const playerWrapper = playerContainer.querySelector('.youtube-player-wrapper');
            const youtubeLink = playerContainer.querySelector('.youtube-link');
            
            // Clear any existing content
            playerWrapper.innerHTML = '';
            
            // Update UI while loading
            timeDisplay.textContent = "Loading...";
            timeDisplay.classList.add('loading');
            
            // Scroll to make sure the player is visible
            setTimeout(() => {
                playerContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }, 100);
            
            // Search for the video and create player
            searchAndPlayVideo(trackName, playerWrapper, playPauseBtn, timeDisplay, youtubeLink);
            
            // Set up play/pause button functionality
            playPauseBtn.onclick = function() {
                if (!currentPlayer) return;
                
                try {
                    const state = currentPlayer.getPlayerState();
                    if (state === YT.PlayerState.PLAYING) {
                        currentPlayer.pauseVideo();
                    } else {
                        currentPlayer.playVideo();
                    }
                } catch (e) {
                    console.error("Error toggling playback:", e);
                }
            };
        });
    });

    // Function to search for a video and play it
    function searchAndPlayVideo(trackName, playerContainer, playPauseBtn, timeDisplay, youtubeLink) {
        // Show loading state
        timeDisplay.textContent = "Loading...";
        timeDisplay.classList.add('loading');
        
        console.log("Searching for video:", trackName);

        fetch(`/search_video?query=${encodeURIComponent(trackName)}`)
            .then(response => {
                console.log("Search API response status:", response.status);
                return response.json();
            })
            .then(data => {
                console.log("Search API response data:", data);
                if (data.videoId) {
                    // Update YouTube link immediately
                    youtubeLink.href = `https://www.youtube.com/watch?v=${data.videoId}`;
                    
                    waitForYouTubeAPI(() => {
                        currentPlayer = createPlayer(playerContainer, data.videoId, playPauseBtn, timeDisplay);
                        currentPlayerContainer = playerContainer;
                        timeDisplay.classList.remove('loading'); // Remove loading state
                    });
                } else {
                    console.error("No video ID returned");
                    timeDisplay.textContent = "Not found";
                    timeDisplay.classList.remove('loading');
                    youtubeLink.href = `https://www.youtube.com/results?search_query=${encodeURIComponent(trackName)}`;
                    
                    // If in play all mode and no video found, move to the next track
                    if (isPlayingAll) {
                        setTimeout(() => playNextTrack(), 1000);
                    }
                }
            })
            .catch(error => {
                console.error('Error searching for video:', error);
                timeDisplay.textContent = "Error";
                timeDisplay.classList.remove('loading');
                youtubeLink.href = `https://www.youtube.com/results?search_query=${encodeURIComponent(trackName)}`;
                
                // If in play all mode and there's an error, move to the next track
                if (isPlayingAll) {
                    setTimeout(() => playNextTrack(), 1000);
                }
            });
    }
});
</script>
{% endblock %} 