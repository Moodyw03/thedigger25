{% extends 'base.html' %}

{% block title %}The Digger - Find DJ Tracklists{% endblock %}

{% block content %}
<div class="search-section">
    <form id="search-form" class="search-form">
        <input type="text" id="artist-name-input" name="artist_name" value="{{ artist_name if artist_name else '' }}" placeholder="Enter artist name (e.g., Ben UFO)" required>
        <button type="submit" id="search-button">Find Tracklists</button>
    </form>
    
    <div id="progress-indicator" class="progress-bar-container" style="display: none;">
        <div class="progress-bar">
            <div class="progress-bar-fill" id="progress-bar-fill"></div>
        </div>
        <p class="progress-status" id="progress-status">Starting search...</p>
    </div>

    <div id="error-container" class="error" style="display: none;"></div>

    <div id="results-container">
        <!-- Results will be dynamically injected here -->
        <!-- Keep existing structure for PDF download etc if needed outside results -->
    </div>

    <div class="search-options">
        <span class="search-options-text">Or get a PDF directly:</span>
        <form action="{{ url_for('background_pdf') }}" method="get" class="direct-pdf-form">
            <input type="text" name="artist_name" placeholder="Enter artist name" required>
            <button type="submit" class="pdf-button">
                <svg class="pdf-icon" viewBox="0 0 24 24" width="18" height="18">
                    <path d="M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8.5 7.5c0 .83-.67 1.5-1.5 1.5H9v2H7.5V7H10c.83 0 1.5.67 1.5 1.5v1zm5 2c0 .83-.67 1.5-1.5 1.5h-2.5V7H15c.83 0 1.5.67 1.5 1.5v3zm4-3H19v1h1.5V11H19v2h-1.5V7h3v1.5zM9 9.5h1v-1H9v1zM4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm10 5.5h1v-3h-1v3z" fill="currentColor"/>
                </svg>
                Download PDF
            </button>
        </form>
        <p class="direct-pdf-hint">Works with both small and large catalogs using background processing</p>
    </div>
</div>

{% endblock %}

{% block scripts %}
<script>
// Create script tag for YouTube iframe API programmatically
const tag = document.createElement('script');
tag.src = "https://www.youtube.com/iframe_api";
const firstScriptTag = document.getElementsByTagName('script')[0];
firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

// Main app logic
document.addEventListener('DOMContentLoaded', function() {
    const searchForm = document.getElementById('search-form');
    const searchInput = document.getElementById('artist-name-input');
    const searchButton = document.getElementById('search-button');
    const progressIndicator = document.getElementById('progress-indicator');
    const progressBarFill = document.getElementById('progress-bar-fill');
    const progressStatus = document.getElementById('progress-status');
    const errorContainer = document.getElementById('error-container');
    const resultsContainer = document.getElementById('results-container');
    
    let pollingInterval = null;
    let currentJobId = null;

    // Focus the input field when the page loads
    searchInput.focus();
    
    // Auto-select all text when input field is clicked
    searchInput.addEventListener('click', function() {
        this.select();
    });

    // Handle Search Form Submission
    searchForm.addEventListener('submit', async function(e) {
        e.preventDefault(); // Prevent default GET submission
        
        const artistName = searchInput.value.trim();
        if (!artistName) {
            showError("Please enter an artist name.");
            return;
        }

        // Reset UI
        hideError();
        clearResults();
        if (pollingInterval) clearInterval(pollingInterval); // Clear previous polling
        progressStatus.textContent = 'Sending request...';
        progressBarFill.style.width = '5%'; 
        progressIndicator.style.display = 'block';
        searchButton.disabled = true;
        searchButton.textContent = 'Searching...';

        try {
            const formData = new FormData();
            formData.append('artist_name', artistName);

            const response = await fetch("{{ url_for('start_search_job') }}", {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                let errorMsg = `Error starting search: ${response.statusText}`;
                try {
                    const errData = await response.json();
                    errorMsg = errData.error || errorMsg;
                } catch (jsonErr) { /* Ignore if response is not JSON */ }
                throw new Error(errorMsg);
            }

            const data = await response.json();
            currentJobId = data.job_id;
            progressStatus.textContent = 'Search job started. Waiting for progress...';
            progressBarFill.style.width = '10%';
            pollJobStatus(currentJobId); // Start polling

        } catch (error) {
            console.error("Error submitting search:", error);
            showError(error.message || "Failed to start search job.");
            resetUiOnError();
        }
    });

    function pollJobStatus(jobId) {
        pollingInterval = setInterval(async () => {
            if (jobId !== currentJobId) {
                // Stop polling if a new search has started
                clearInterval(pollingInterval);
                return;
            }
            try {
                const response = await fetch(`/job/${jobId}/status`);
                if (!response.ok) {
                     // Stop polling on server error, but keep message
                    if (response.status >= 500) {
                       progressStatus.textContent = `Polling error: ${response.statusText}. Retrying...`;
                       // Don't throw error yet, maybe transient
                       return; 
                    } else {
                         throw new Error(`Status check failed: ${response.statusText}`);
                    }
                }

                const data = await response.json();

                switch(data.status) {
                    case 'queued':
                        progressStatus.textContent = 'Job is queued...';
                        progressBarFill.style.width = '20%';
                        break;
                    case 'started':
                        // Could potentially use job.meta here if the backend provides progress
                        progressStatus.textContent = 'Scraping in progress...'; 
                        progressBarFill.style.width = '50%';
                        break;
                    case 'finished':
                        clearInterval(pollingInterval);
                        progressStatus.textContent = 'Fetching results...';
                        progressBarFill.style.width = '90%';
                        fetchJobResult(jobId);
                        break;
                    case 'failed':
                        clearInterval(pollingInterval);
                        showError(`Job failed: ${data.error_message || 'Unknown error'}`);
                        resetUiOnError();
                        break;
                    case 'not_found':
                        clearInterval(pollingInterval);
                        showError('Job ID not found. Please try again.');
                        resetUiOnError();
                        break;
                    default:
                        progressStatus.textContent = `Status: ${data.status}`;
                }
            } catch (error) {
                console.error("Polling error:", error);
                // Stop polling on network or unexpected errors
                clearInterval(pollingInterval);
                showError(error.message || "Error checking job status.");
                resetUiOnError();
            }
        }, 3000); // Poll every 3 seconds
    }

    async function fetchJobResult(jobId) {
        try {
            const response = await fetch(`/job/${jobId}/result`);
            if (!response.ok) {
                let errorMsg = `Error fetching results: ${response.statusText}`;
                 try {
                    const errData = await response.json();
                    errorMsg = errData.error || errorMsg;
                } catch (jsonErr) { /* Ignore if response is not JSON */ }
                throw new Error(errorMsg);
            }

            const resultData = await response.json();

            if (resultData.status === 'finished') {
                 progressStatus.textContent = 'Search complete!';
                 progressBarFill.style.width = '100%';
                 // Keep progress bar visible briefly for completion message
                 setTimeout(() => {
                     progressIndicator.style.display = 'none';
                 }, 1500);
                 renderResults(resultData.data); // Render the track data
            } else {
                // Should not happen if status was finished, but handle defensively
                throw new Error(resultData.error || 'Failed to get results despite finished status.');
            }
            
        } catch (error) {
            console.error("Error fetching results:", error);
            showError(error.message || "Failed to fetch results.");
            resetUiOnError();
        }
    }

    function renderResults(tracks) {
        clearResults();
        if (!tracks || tracks.length === 0) {
            showError("No tracklists found for the artist.");
            resetUiOnCompletion();
            return;
        }

        const artistName = searchInput.value.trim(); // Get artist name again for display
        const resultsSection = document.createElement('div');
        resultsSection.className = 'results-section';

        let totalTracksCount = 0;
        let mixesWithTracklistsCount = 0;
        tracks.forEach(mix => {
            if (mix.has_tracklist && mix.tracks) {
                mixesWithTracklistsCount++;
                totalTracksCount += mix.tracks.length;
            }
        });

        // --- Recreate the header and action buttons --- 
        resultsSection.innerHTML = `
            <h2>Tracklists for ${escapeHtml(artistName)}</h2>
            <p>Found ${totalTracksCount} tracks across ${mixesWithTracklistsCount} mixes with tracklists (${tracks.length} total mixes)</p>
            <div class="results-actions">
                <a href="{{ url_for('background_pdf') }}?artist_name=${encodeURIComponent(artistName)}" class="download-pdf-btn" title="Download all tracklists as PDF">
                     <svg class="pdf-icon" viewBox="0 0 24 24" width="24" height="24">
                        <path d="M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8.5 7.5c0 .83-.67 1.5-1.5 1.5H9v2H7.5V7H10c.83 0 1.5.67 1.5 1.5v1zm5 2c0 .83-.67 1.5-1.5 1.5h-2.5V7H15c.83 0 1.5.67 1.5 1.5v3zm4-3H19v1h1.5V11H19v2h-1.5V7h3v1.5zM9 9.5h1v-1H9v1zM4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm10 5.5h1v-3h-1v3z" fill="currentColor"/>
                    </svg>
                    Download PDF
                </a>
                <div class="playback-controls">
                    <button id="play-all-btn" class="play-all-button" title="Play all tracks">
                         <svg class="play-all-icon" viewBox="0 0 24 24" width="24" height="24">
                            <path d="M8 5v14l11-7z" fill="currentColor"/>
                        </svg>
                        Play All Tracks
                    </button>
                    <button id="skip-track-btn" class="skip-track-button" title="Skip to next track" disabled>
                         <svg class="skip-icon" viewBox="0 0 24 24" width="24" height="24">
                            <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z" fill="currentColor"/>
                        </svg>
                        Skip
                    </button>
                </div>
            </div>
            <div class="filters">
                <label>
                    <input type="checkbox" id="show-all-mixes" checked>
                    Show mixes without tracklists
                </label>
            </div>
            <div class="mixes-container">
                <!-- Mix sections will be appended here -->
            </div>
        `;
        
        const mixesContainer = resultsSection.querySelector('.mixes-container');

        // --- Create each mix section --- 
        tracks.forEach(mix => {
            const mixSection = document.createElement('div');
            mixSection.className = `mix-section ${mix.has_tracklist ? '' : 'mix-no-tracklist'}`;
            
            const mixHeader = document.createElement('div');
            mixHeader.className = 'mix-header';
            mixHeader.innerHTML = `
                <h3 class="mix-title">
                    ${escapeHtml(mix.title)}
                    ${mix.date ? `<span class="mix-date">(${escapeHtml(mix.date)})</span>` : ''}
                </h3>
                <div class="mix-badges">
                    ${mix.has_tracklist ? `<span class="tracklist-badge">${mix.tracks.length} tracks</span>` : '<span class="no-tracklist-badge">No tracklist available</span>'}
                </div>
            `;

            const mixActions = document.createElement('div');
            mixActions.className = 'mix-actions';
            if (mix.url) {
                mixActions.innerHTML = `<a href="${escapeHtml(mix.url)}" class="mix-link" target="_blank">View on MixesDB</a>`;
            }

            mixSection.appendChild(mixHeader);
            mixSection.appendChild(mixActions);

            if (mix.has_tracklist && mix.tracks) {
                const tracklistContainer = document.createElement('div');
                tracklistContainer.className = 'tracklist-container';
                tracklistContainer.innerHTML = '<h4 class="tracklist-header">Tracklist:</h4>';
                
                const trackListOl = document.createElement('ol');
                trackListOl.className = 'track-list';

                mix.tracks.forEach(track => {
                    const trackLi = document.createElement('li');
                    trackLi.className = 'track-item';
                    trackLi.innerHTML = `
                        <div class="track-info">
                            <span class="track-name">${escapeHtml(track.track)}</span>
                            <button class="play-button" data-track="${encodeURIComponent(track.track)}" title="Play track">
                                <span class="play-icon">▶</span> Play
                            </button>
                        </div>
                        <div class="inline-player-container" style="display: none;">
                            <div class="player-controls">
                                <div class="audio-controls">
                                    <span class="control-btn play-pause-btn">⏸</span>
                                    <span class="time-display">0:00</span>
                                    <a href="#" class="youtube-link" target="_blank" title="View on YouTube">
                                         <svg class="youtube-icon" viewBox="0 0 24 24" width="22" height="22">
                                            <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z" fill="#ff0000"/>
                                        </svg>
                                    </a>
                                </div>
                                <div class="youtube-player-wrapper">
                                    <!-- YouTube player will be inserted here -->
                                </div>
                            </div>
                        </div>
                    `;
                    trackListOl.appendChild(trackLi);
                });
                tracklistContainer.appendChild(trackListOl);
                mixSection.appendChild(tracklistContainer);
            } else {
                 mixSection.innerHTML += '<p class="no-tracks-message">No tracklist is available for this mix.</p>';
            }
            mixesContainer.appendChild(mixSection);
        });

        resultsContainer.appendChild(resultsSection);
        
        // Re-attach event listeners for dynamic content
        initializeDynamicContentListeners(resultsSection);
        resetUiOnCompletion();
    }

    function initializeDynamicContentListeners(container) {
        // Re-initialize YouTube player logic for new buttons
        // Assumes player logic functions are defined elsewhere (or included below)
        setupPlayButtons(container);
        setupPlayAllButton(container);
        setupSkipButton(container);
        setupFilterCheckbox(container);
    }
    
    function escapeHtml(unsafe) {
        if (!unsafe) return '';
        return unsafe
             .replace(/&/g, "&amp;")
             .replace(/</g, "&lt;")
             .replace(/>/g, "&gt;")
             .replace(/"/g, "&quot;")
             .replace(/'/g, "&#039;");
     }

    // --- UI Helper Functions ---
    function showError(message) {
        errorContainer.textContent = message;
        errorContainer.style.display = 'block';
        progressIndicator.style.display = 'none'; // Hide progress on error
    }
    function hideError() {
        errorContainer.style.display = 'none';
        errorContainer.textContent = '';
    }
    function clearResults() {
        resultsContainer.innerHTML = '';
    }
    function resetUiOnError() {
         searchButton.disabled = false;
         searchButton.textContent = 'Find Tracklists';
         progressIndicator.style.display = 'none';
         if (pollingInterval) clearInterval(pollingInterval);
         currentJobId = null;
    }
     function resetUiOnCompletion() {
         searchButton.disabled = false;
         searchButton.textContent = 'Find Tracklists';
         if (pollingInterval) clearInterval(pollingInterval);
         currentJobId = null;
         // Progress indicator is hidden by fetchJobResult after a delay
    }

    // --- PDF form logic (remains mostly unchanged) ---
    const directPdfForm = document.querySelector('.direct-pdf-form');
    if (directPdfForm) {
        directPdfForm.addEventListener('submit', function(e) {
            if (directPdfForm.checkValidity()) {
                const pdfBtn = directPdfForm.querySelector('.pdf-button');
                pdfBtn.disabled = true;
                pdfBtn.innerHTML = `
                     <svg class="pdf-icon" viewBox="0 0 24 24" width="18" height="18">
                        <path d="M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8.5 7.5c0 .83-.67 1.5-1.5 1.5H9v2H7.5V7H10c.83 0 1.5.67 1.5 1.5v1zm5 2c0 .83-.67 1.5-1.5 1.5h-2.5V7H15c.83 0 1.5.67 1.5 1.5v3zm4-3H19v1h1.5V11H19v2h-1.5V7h3v1.5zM9 9.5h1v-1H9v1zM4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm10 5.5h1v-3h-1v3z" fill="currentColor"/>
                    </svg>
                    Generating PDF...
                `;
            }
        });
    }

    // --- YouTube Player Logic (Needs to be adapted/included) ---
    // IMPORTANT: The original YouTube player functions (onYouTubeIframeAPIReady, 
    // setupPlayButtons, playTrack, createPlayer, onPlayerReady, onPlayerStateChange, 
    // updateProgressBar, etc.) need to be included here or in a separate file. 
    // They must be adapted to work with dynamically added elements.
    // The setupPlayButtons, setupPlayAllButton, etc. calls within 
    // initializeDynamicContentListeners assume these functions exist.

    // Placeholder for YouTube player functions - REPLACE with actual functions
    let currentPlayer = null;
    let youtubeReady = false;
    let activeTrackItem = null;
    let updateTimeInterval = null;
    let trackQueue = [];
    let currentTrackIndex = -1;
    let isPlayingAll = false;
    let switchTrackTimeout = null;
    const TRACK_PLAY_DURATION = 120000; // 2 minutes

    window.onYouTubeIframeAPIReady = function() {
        youtubeReady = true;
        console.log("YouTube API is ready (Dynamic)");
        // Any initial setup needed after API loads
    };

    function setupPlayButtons(container) {
        const playButtons = container.querySelectorAll('.play-button');
        playButtons.forEach(button => {
            button.addEventListener('click', function() {
                if (!youtubeReady) {
                    console.warn("YouTube API not ready yet.");
                    showError("Player is loading, please wait...");
                    return;
                }
                const trackName = decodeURIComponent(this.dataset.track);
                const trackItem = this.closest('.track-item');
                playTrack(trackName, trackItem);
            });
        });
    }
    
    function setupPlayAllButton(container) {
        const playAllBtn = container.querySelector('#play-all-btn');
        if (playAllBtn) {
             // Attach listener here instead of globally
             playAllBtn.addEventListener('click', function() {
                 if (isPlayingAll) {
                     stopPlayAll();
                 } else {
                     startPlayAll();
                 }
             });
        }
    }

    function setupSkipButton(container) {
         const skipBtn = container.querySelector('#skip-track-btn');
         if(skipBtn) {
             // Attach listener here instead of globally
            skipBtn.addEventListener('click', skipTrack);
         }
    }
    
    function setupFilterCheckbox(container) {
         const showAllMixesCheckbox = container.querySelector('#show-all-mixes');
         if (showAllMixesCheckbox) {
            showAllMixesCheckbox.addEventListener('change', function() {
                const noTracklistMixes = container.querySelectorAll('.mix-no-tracklist');
                noTracklistMixes.forEach(mix => {
                    mix.style.display = this.checked ? 'block' : 'none';
                });
            });
            // Trigger change once to apply initial state
            showAllMixesCheckbox.dispatchEvent(new Event('change')); 
        }
    }

    // --- Placeholder playTrack function --- 
    // Replace with your actual YouTube player implementation
    async function playTrack(trackName, trackItemElement) {
        console.log(`Attempting to play: ${trackName}`);
        hideError(); // Clear previous errors

        // Deactivate previous player
        if (activeTrackItem && activeTrackItem !== trackItemElement) {
            deactivatePlayer(activeTrackItem);
        }
        
        activeTrackItem = trackItemElement;
        const playerContainer = activeTrackItem.querySelector('.inline-player-container');
        const playerWrapper = activeTrackItem.querySelector('.youtube-player-wrapper');
        const playerControls = activeTrackItem.querySelector('.player-controls');
        const playButton = activeTrackItem.querySelector('.play-button');

        // Show loading state for this track
        playerWrapper.innerHTML = '<p class="player-loading">Searching for video...</p>';
        playerContainer.style.display = 'block';
        playButton.innerHTML = '<span class="loading-icon"></span> Loading...';
        playButton.disabled = true;

        try {
            // Simulate fetching video ID - replace with actual fetch
            // const videoId = await fetchVideoId(trackName);
            const videoId = await new Promise(resolve => setTimeout(() => resolve('dQw4w9WgXcQ'), 500)); // Placeholder

            if (!videoId) {
                throw new Error("Could not find video for this track.");
            }
            
            // Create player
            playerWrapper.innerHTML = '<div id="youtube-player-' + Date.now() + '"></div>'; // Unique ID
            const playerDivId = playerWrapper.firstElementChild.id;

            createPlayer(playerDivId, videoId, playerControls);
            playButton.innerHTML = '<span class="play-icon">▶</span> Play'; // Reset button text maybe?
            playButton.disabled = false; // Re-enable once loaded
            // Player controls (like play/pause button) will be handled by YT API callbacks

        } catch (error) {
            console.error("Error playing track:", error);
            showError(`Could not play track: ${error.message}`);
            playerWrapper.innerHTML = `<p class="player-error">Error: ${error.message}</p>`;
             playButton.innerHTML = '<span class="play-icon">▶</span> Play';
             playButton.disabled = false;
             // Optionally hide container after error
             // setTimeout(() => { playerContainer.style.display = 'none'; }, 3000);
        }
    }
    
    function deactivatePlayer(trackItemElement) {
        const playerContainer = trackItemElement.querySelector('.inline-player-container');
        const playerWrapper = trackItemElement.querySelector('.youtube-player-wrapper');
        const playButton = trackItemElement.querySelector('.play-button');
        
        if (currentPlayer && typeof currentPlayer.stopVideo === 'function') {
            currentPlayer.stopVideo();
            currentPlayer.destroy(); // Clean up player instance
            console.log("Previous player stopped and destroyed");
        }
        currentPlayer = null;
        playerContainer.style.display = 'none';
        playerWrapper.innerHTML = ''; // Clear player div
        if(playButton) {
            playButton.innerHTML = '<span class="play-icon">▶</span> Play';
            playButton.disabled = false;
        }
        if (updateTimeInterval) clearInterval(updateTimeInterval);
        activeTrackItem = null;
    }
    
    function createPlayer(elementId, videoId, controlsElement) {
         console.log(`Creating player for ${elementId} with video ${videoId}`);
         const playPauseBtn = controlsElement.querySelector('.play-pause-btn');
         const timeDisplay = controlsElement.querySelector('.time-display');
         const youtubeLink = controlsElement.querySelector('.youtube-link');
         
         youtubeLink.href = `https://www.youtube.com/watch?v=${videoId}`;

         // Reset UI elements
         timeDisplay.textContent = '0:00';
         playPauseBtn.textContent = '⏸'; // Assume playing initially

         currentPlayer = new YT.Player(elementId, {
            height: '90', // Smaller height for audio focus
            width: '160',
            videoId: videoId,
            playerVars: {
                'playsinline': 1,
                'controls': 0, // Hide native controls
                'disablekb': 1,
                'modestbranding': 1,
                'start': 120 // Start at 2 minutes (120 seconds)
            },
            events: {
                'onReady': (event) => onPlayerReady(event, playPauseBtn),
                'onStateChange': (event) => onPlayerStateChange(event, playPauseBtn, timeDisplay, youtubeLink)
            }
        });
    }

    function onPlayerReady(event, playPauseBtn) {
        console.log("Player ready:", event.target);
        event.target.playVideo();
        // Setup custom controls
        playPauseBtn.onclick = () => {
            const playerState = event.target.getPlayerState();
            if (playerState === YT.PlayerState.PLAYING) {
                event.target.pauseVideo();
            } else {
                event.target.playVideo();
            }
        };
    }

    function onPlayerStateChange(event, playPauseBtn, timeDisplay, youtubeLink) {
        const playerState = event.data;
        console.log("Player state changed:", playerState);
        if (updateTimeInterval) clearInterval(updateTimeInterval);

        if (playerState === YT.PlayerState.PLAYING) {
            playPauseBtn.textContent = '⏸'; // Pause symbol
            updateTimeInterval = setInterval(() => {
                const currentTime = event.target.getCurrentTime();
                timeDisplay.textContent = formatTime(currentTime);
            }, 1000);
        } else if (playerState === YT.PlayerState.PAUSED) {
            playPauseBtn.textContent = '▶'; // Play symbol
        } else if (playerState === YT.PlayerState.ENDED) {
            playPauseBtn.textContent = '▶'; // Play symbol
             timeDisplay.textContent = 'Ended';
             // If playing all, automatically skip to the next track
             if (isPlayingAll) {
                console.log("Track ended during Play All, skipping...");
                skipTrack();
             }
        } else if (playerState === YT.PlayerState.BUFFERING) {
            timeDisplay.textContent = 'Buffering...';
        } else {
             playPauseBtn.textContent = '▶'; // Default to Play
        }
    }
    
    function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = Math.floor(seconds % 60);
        return `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
    }

    // --- Placeholder Play All/Skip functions ---
     function startPlayAll() {
        console.log("Starting Play All");
        const allPlayButtons = resultsContainer.querySelectorAll('.play-button');
        trackQueue = Array.from(allPlayButtons).map(btn => ({ 
            button: btn, 
            trackName: decodeURIComponent(btn.dataset.track),
            trackItem: btn.closest('.track-item')
         }));
        
        if (trackQueue.length > 0) {
            currentTrackIndex = 0;
            isPlayingAll = true;
            document.getElementById('skip-track-btn').disabled = false;
            document.getElementById('play-all-btn').textContent = 'Stop Play All'; // Change button text
            playTrackFromQueue(currentTrackIndex);
        } else {
            showError("No tracks found to play.");
        }
    }
    
    function stopPlayAll() {
         console.log("Stopping Play All");
         isPlayingAll = false;
         if (currentPlayer && typeof currentPlayer.stopVideo === 'function') {
            deactivatePlayer(activeTrackItem);
         }
         if (switchTrackTimeout) clearTimeout(switchTrackTimeout);
         document.getElementById('skip-track-btn').disabled = true;
         document.getElementById('play-all-btn').textContent = 'Play All Tracks';
         trackQueue = [];
         currentTrackIndex = -1;
    }
    
    function playTrackFromQueue(index) {
        if (index < 0 || index >= trackQueue.length || !isPlayingAll) {
             console.log("Play All finished or stopped.");
             stopPlayAll();
             return;
        }
        const item = trackQueue[index];
        console.log(`Play All: Playing track ${index + 1}/${trackQueue.length}: ${item.trackName}`);
        playTrack(item.trackName, item.trackItem);
        
        // Set timeout to automatically skip to the next track after TRACK_PLAY_DURATION
        // Clear any existing timeout first
        if (switchTrackTimeout) clearTimeout(switchTrackTimeout);
        switchTrackTimeout = setTimeout(() => {
            console.log(`Play All: Time limit reached for track ${index + 1}, skipping...`);
            skipTrack();
        }, TRACK_PLAY_DURATION);
    }

    function skipTrack() {
         if (!isPlayingAll) return;
         if (switchTrackTimeout) clearTimeout(switchTrackTimeout); // Clear timer if manually skipping
         
         currentTrackIndex++;
         if (currentTrackIndex < trackQueue.length) {
            console.log("Skipping to next track");
            playTrackFromQueue(currentTrackIndex);
         } else {
             console.log("Play All: Reached end of queue.");
             stopPlayAll();
         }
    }
    
    // Initial setup for any static listeners if needed (e.g. direct PDF form)
    // The dynamic content listeners are called after results are rendered.

});
</script>
{% endblock %} 