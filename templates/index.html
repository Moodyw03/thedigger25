{% extends 'base.html' %}

{% block title %}The Digger - Find DJ Tracklists{% endblock %}

{% block content %}
<div class="search-section">
    <form action="{{ url_for('search') }}" method="get" class="search-form">
        <input type="text" name="artist_name" value="{{ artist_name if artist_name else '' }}" placeholder="Enter artist name (e.g., Ben UFO)" required>
        <button type="submit">Find Tracklists</button>
    </form>
</div>

{% if error %}
<div class="error">
    {{ error }}
</div>
{% endif %}

{% if tracks %}
<div class="results-section">
    <h2>Tracklists for {{ artist_name }}</h2>
    
    {% set total_tracks = 0 %}
    {% set mixes_with_tracklists = 0 %}
    {% for mix in tracks %}
        {% if mix.has_tracklist %}
            {% set mixes_with_tracklists = mixes_with_tracklists + 1 %}
            {% set total_tracks = total_tracks + mix.tracks|length %}
        {% endif %}
    {% endfor %}
    
    <p>Found {{ total_tracks }} tracks across {{ mixes_with_tracklists }} mixes with tracklists ({{ tracks|length }} total mixes)</p>
    
    <div class="results-actions">
        <a href="{{ url_for('download_tracklists_pdf', artist_name=artist_name) }}" class="download-pdf-btn" title="Download all tracklists as PDF">
            <svg class="pdf-icon" viewBox="0 0 24 24" width="24" height="24">
                <path d="M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8.5 7.5c0 .83-.67 1.5-1.5 1.5H9v2H7.5V7H10c.83 0 1.5.67 1.5 1.5v1zm5 2c0 .83-.67 1.5-1.5 1.5h-2.5V7H15c.83 0 1.5.67 1.5 1.5v3zm4-3H19v1h1.5V11H19v2h-1.5V7h3v1.5zM9 9.5h1v-1H9v1zM4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm10 5.5h1v-3h-1v3z" fill="currentColor"/>
            </svg>
            Download PDF
        </a>
    </div>
    
    <div class="filters">
        <label>
            <input type="checkbox" id="show-all-mixes" checked>
            Show mixes without tracklists
        </label>
    </div>
    
    <div class="mixes-container">
        {% for mix in tracks %}
        <div class="mix-section {% if not mix.has_tracklist %}mix-no-tracklist{% endif %}">
            <div class="mix-header">
                <h3 class="mix-title">
                    {{ mix.title }}
                    {% if mix.date %}
                    <span class="mix-date">({{ mix.date }})</span>
                    {% endif %}
                </h3>
                
                <div class="mix-badges">
                    {% if mix.has_tracklist %}
                    <span class="tracklist-badge">{{ mix.tracks|length }} tracks</span>
                    {% else %}
                    <span class="no-tracklist-badge">No tracklist available</span>
                    {% endif %}
                </div>
            </div>
            
            <div class="mix-actions">
                {% if mix.url %}
                <a href="{{ mix.url }}" class="mix-link" target="_blank">View on MixesDB</a>
                {% endif %}
            </div>
            
            {% if mix.has_tracklist %}
            <div class="tracklist-container">
                <h4 class="tracklist-header">Tracklist:</h4>
                <ol class="track-list">
                    {% for track in mix.tracks %}
                    <li class="track-item">
                        <div class="track-info">
                            <span class="track-name">{{ track.track }}</span>
                            <button class="play-button" data-track="{{ track.track|urlencode }}" title="Play track">
                                <span class="play-icon">▶</span> Play
                            </button>
                        </div>
                        <!-- Inline player will be inserted here when track is played -->
                        <div class="inline-player-container" style="display: none;">
                            <div class="player-controls">
                                <div class="audio-controls">
                                    <span class="control-btn play-pause-btn">⏸</span>
                                    <span class="time-display">0:00</span>
                                    <a href="#" class="youtube-link" target="_blank" title="View on YouTube">
                                        <svg class="youtube-icon" viewBox="0 0 24 24" width="18" height="18">
                                            <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z" fill="currentColor"/>
                                        </svg>
                                    </a>
                                </div>
                                <div class="youtube-player-wrapper">
                                    <!-- YouTube player will be inserted here -->
                                </div>
                            </div>
                        </div>
                    </li>
                    {% endfor %}
                </ol>
            </div>
            {% else %}
            <p class="no-tracks-message">No tracklist is available for this mix.</p>
            {% endif %}
        </div>
        {% endfor %}
    </div>
</div>
{% endif %}
{% endblock %}

{% block scripts %}
<script>
// Create script tag for YouTube iframe API programmatically
const tag = document.createElement('script');
tag.src = "https://www.youtube.com/iframe_api";
const firstScriptTag = document.getElementsByTagName('script')[0];
firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

// Main app logic
document.addEventListener('DOMContentLoaded', function() {
    const searchForm = document.querySelector('.search-form');
    const searchInput = searchForm.querySelector('input[name="artist_name"]');
    
    // Focus the input field when the page loads
    searchInput.focus();
    
    // Auto-select all text when input field is clicked
    searchInput.addEventListener('click', function() {
        this.select();
    });

    // Filter checkbox for mixes without tracklists
    const showAllMixesCheckbox = document.getElementById('show-all-mixes');
    if (showAllMixesCheckbox) {
        showAllMixesCheckbox.addEventListener('change', function() {
            const noTracklistMixes = document.querySelectorAll('.mix-no-tracklist');
            noTracklistMixes.forEach(mix => {
                mix.style.display = this.checked ? 'block' : 'none';
            });
        });
    }

    // YouTube player variables
    let currentPlayer = null;
    let currentPlayerContainer = null;
    let youtubeReady = false;
    let updateTimeInterval;
    let activeTrackItem = null;
    let waitingQueue = [];

    // Initialize YouTube API
    window.onYouTubeIframeAPIReady = function() {
        youtubeReady = true;
        console.log("YouTube API is ready");
        
        // Process any waiting players
        while (waitingQueue.length > 0) {
            const task = waitingQueue.shift();
            task();
        }
    };

    function waitForYouTubeAPI(callback) {
        if (youtubeReady) {
            callback();
        } else {
            console.log("YouTube API not ready, adding to queue");
            waitingQueue.push(callback);
        }
    }

    // Format time in minutes:seconds
    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs < 10 ? '0' + secs : secs}`;
    }

    // Start updating the time display
    function startTimeUpdate(player, timeDisplay) {
        stopTimeUpdate(); // Clear any existing interval
        updateTimeInterval = setInterval(() => {
            if (player) {
                const currentTime = player.getCurrentTime();
                timeDisplay.textContent = formatTime(currentTime);
            }
        }, 1000);
    }

    // Stop updating the time display
    function stopTimeUpdate() {
        if (updateTimeInterval) {
            clearInterval(updateTimeInterval);
        }
    }

    // Handle player state changes
    function onPlayerStateChange(event, playPauseBtn, timeDisplay) {
        console.log("Player state changed:", event.data);
        if (event.data === YT.PlayerState.PLAYING) {
            playPauseBtn.textContent = '⏸';
            startTimeUpdate(event.target, timeDisplay);
        } else if (event.data === YT.PlayerState.PAUSED) {
            playPauseBtn.textContent = '▶';
            stopTimeUpdate();
        } else if (event.data === YT.PlayerState.ENDED) {
            playPauseBtn.textContent = '▶';
            stopTimeUpdate();
        }
    }

    // Create a new YouTube player
    function createPlayer(container, videoId, playPauseBtn, timeDisplay) {
        console.log("Creating player for video ID:", videoId);
        
        // If there's already a player, stop and destroy it
        if (currentPlayer) {
            try {
                currentPlayer.stopVideo();
                currentPlayer.destroy();
            } catch (e) {
                console.error("Error destroying previous player:", e);
            }
            currentPlayer = null;
        }

        // Create a placeholder for the iframe
        const playerPlaceholder = document.createElement('div');
        container.appendChild(playerPlaceholder);

        // Create new player
        try {
            const player = new YT.Player(playerPlaceholder, {
                height: '1',  // Minimal height - we're using it just for audio
                width: '1',   // Minimal width - we're using it just for audio
                videoId: videoId,
                playerVars: {
                    'autoplay': 1,
                    'controls': 0,
                    'disablekb': 1,
                    'fs': 0,
                    'modestbranding': 1,
                    'start': 120,  // Start at 2 minutes
                    'iv_load_policy': 3
                },
                events: {
                    'onStateChange': (event) => onPlayerStateChange(event, playPauseBtn, timeDisplay),
                    'onReady': (event) => {
                        console.log("Player ready event");
                        timeDisplay.textContent = "0:00"; // Reset time display when player is ready
                        event.target.playVideo();
                    },
                    'onError': (event) => {
                        console.error("Player error:", event.data);
                        
                        // Show error message to user
                        const errorMessages = {
                            2: "Invalid video ID",
                            5: "HTML5 player error",
                            100: "Video not found or removed",
                            101: "Video owner doesn't allow embedded playback",
                            150: "Video owner doesn't allow embedded playback"
                        };
                        
                        const errorMsg = errorMessages[event.data] || "Unknown error playing video";
                        timeDisplay.textContent = "Error";
                        timeDisplay.title = errorMsg;
                    }
                }
            });
            return player;
        } catch (e) {
            console.error("Error creating YouTube player:", e);
            return null;
        }
    }

    // Handle play button clicks
    const playButtons = document.querySelectorAll('.play-button');
    playButtons.forEach(button => {
        button.addEventListener('click', function() {
            console.log("Play button clicked");
            
            // Get the track item and details
            const trackItem = this.closest('.track-item');
            const trackName = decodeURIComponent(this.getAttribute('data-track'));
            console.log("Track name:", trackName);
            
            // Show the inline player for this track
            const playerContainer = trackItem.querySelector('.inline-player-container');
            playerContainer.style.display = 'block';
            
            // Set this as the active track
            activeTrackItem = trackItem;
            
            // Get control elements
            const playPauseBtn = playerContainer.querySelector('.play-pause-btn');
            const timeDisplay = playerContainer.querySelector('.time-display');
            const playerWrapper = playerContainer.querySelector('.youtube-player-wrapper');
            const youtubeLink = playerContainer.querySelector('.youtube-link');
            
            // Clear any existing content
            playerWrapper.innerHTML = '';
            
            // Update UI while loading
            timeDisplay.textContent = "Loading...";
            timeDisplay.classList.add('loading');
            
            // Scroll to make sure the player is visible
            setTimeout(() => {
                playerContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }, 100);
            
            // Search for the video and create player
            searchAndPlayVideo(trackName, playerWrapper, playPauseBtn, timeDisplay, youtubeLink);
            
            // Set up play/pause button functionality
            playPauseBtn.onclick = function() {
                if (!currentPlayer) return;
                
                try {
                    const state = currentPlayer.getPlayerState();
                    if (state === YT.PlayerState.PLAYING) {
                        currentPlayer.pauseVideo();
                    } else {
                        currentPlayer.playVideo();
                    }
                } catch (e) {
                    console.error("Error toggling playback:", e);
                }
            };
        });
    });

    // Function to search for a video and play it
    function searchAndPlayVideo(trackName, playerContainer, playPauseBtn, timeDisplay, youtubeLink) {
        // Show loading state
        timeDisplay.textContent = "Loading...";
        timeDisplay.classList.add('loading');
        
        console.log("Searching for video:", trackName);

        fetch(`/search_video?query=${encodeURIComponent(trackName)}`)
            .then(response => {
                console.log("Search API response status:", response.status);
                return response.json();
            })
            .then(data => {
                console.log("Search API response data:", data);
                if (data.videoId) {
                    // Update YouTube link immediately
                    youtubeLink.href = `https://www.youtube.com/watch?v=${data.videoId}`;
                    
                    waitForYouTubeAPI(() => {
                        currentPlayer = createPlayer(playerContainer, data.videoId, playPauseBtn, timeDisplay);
                        currentPlayerContainer = playerContainer;
                        timeDisplay.classList.remove('loading'); // Remove loading state
                    });
                } else {
                    console.error("No video ID returned");
                    timeDisplay.textContent = "Not found";
                    timeDisplay.classList.remove('loading');
                    youtubeLink.href = `https://www.youtube.com/results?search_query=${encodeURIComponent(trackName)}`;
                }
            })
            .catch(error => {
                console.error('Error searching for video:', error);
                timeDisplay.textContent = "Error";
                timeDisplay.classList.remove('loading');
                youtubeLink.href = `https://www.youtube.com/results?search_query=${encodeURIComponent(trackName)}`;
            });
    }
});
</script>
{% endblock %} 