{% extends 'base.html' %}

{% block title %}The Digger - Find DJ Tracklists{% endblock %}

{% block content %}
<style>
    .inline-player-container {
        margin-top: 10px;
        margin-bottom: 15px;
        padding: 15px;
        border-radius: 8px;
        background-color: #f8f8f8;
        border: 1px solid #e0e0e0;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    
    .youtube-player-wrapper {
        margin-bottom: 12px;
        display: flex;
        justify-content: center;
        max-width: 100%;
        overflow: hidden;
    }
    
    .audio-controls {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 0.9em;
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid #eaeaea;
    }
    
    .time-display {
        margin-right: 10px;
        min-width: 120px;
        font-family: monospace;
        font-size: 14px;
    }
    
    .youtube-link {
        display: inline-block;
        padding: 5px 10px;
        border-radius: 4px;
        background-color: #ff0000;
        color: white;
        text-decoration: none;
        font-size: 0.9em;
        font-weight: bold;
        transition: background-color 0.2s;
    }
    
    .youtube-link:hover {
        background-color: #cc0000;
        text-decoration: none;
    }

    .play-button {
        padding: 6px 12px;
        border-radius: 4px;
        background-color: #2a7de1;
        color: white;
        border: none;
        cursor: pointer;
        font-weight: bold;
        transition: background-color 0.2s;
    }

    .play-button:hover {
        background-color: #1c5db9;
    }

    .play-icon, .pause-icon, .replay-icon {
        margin-right: 4px;
    }
    
    /* Track item styling */
    .track-item {
        padding: 12px;
        margin-bottom: 10px;
        border-radius: 6px;
        background-color: #ffffff;
        border: 1px solid #e5e5e5;
        transition: box-shadow 0.2s;
    }
    
    .track-item:hover {
        box-shadow: 0 3px 8px rgba(0,0,0,0.08);
    }
    
    .track-info {
        margin-bottom: 8px;
    }
    
    .track-number {
        display: inline-block;
        font-weight: bold;
        margin-right: 5px;
        min-width: 25px;
    }
    
    .track-name {
        font-size: 15px;
    }
    
    .track-actions {
        margin-top: 6px;
        display: flex;
        justify-content: flex-start;
    }
    
    /* Track list styling */
    .track-list {
        list-style-type: none;
        padding: 0;
        margin: 0;
    }
</style>

<div class="search-section">
    <form id="search-form" class="search-form">
        <input type="text" id="artist-name-input" name="artist_name" value="{{ artist_name if artist_name else '' }}" placeholder="Enter artist name (e.g., Ben UFO)" required>
        <button type="submit" id="search-button">Find Tracklists</button>
    </form>
    
    <div id="progress-indicator" class="progress-bar-container" style="display: none;">
        <div class="progress-bar">
            <div class="progress-bar-fill" id="progress-bar-fill"></div>
        </div>
        <p class="progress-status" id="progress-status">Starting search...</p>
    </div>

    <div id="error-container" class="error" style="display: none;"></div>

    <div id="results-container">
        <!-- Results will be dynamically injected here -->
        <!-- Keep existing structure for PDF download etc if needed outside results -->
    </div>
    
    <div class="search-options">
        <span class="search-options-text">Or get a PDF directly:</span>
        <form action="{{ url_for('background_pdf') }}" method="get" class="direct-pdf-form">
            <input type="text" name="artist_name" placeholder="Enter artist name" required>
            <button type="submit" class="pdf-button">
                <svg class="pdf-icon" viewBox="0 0 24 24" width="18" height="18">
                    <path d="M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8.5 7.5c0 .83-.67 1.5-1.5 1.5H9v2H7.5V7H10c.83 0 1.5.67 1.5 1.5v1zm5 2c0 .83-.67 1.5-1.5 1.5h-2.5V7H15c.83 0 1.5.67 1.5 1.5v3zm4-3H19v1h1.5V11H19v2h-1.5V7h3v1.5zM9 9.5h1v-1H9v1zM4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm10 5.5h1v-3h-1v3z" fill="currentColor"/>
                </svg>
                Download PDF
            </button>
        </form>
        <p class="direct-pdf-hint">Works with both small and large catalogs using background processing</p>
    </div>
</div>

{% endblock %}

{% block scripts %}
<script>
// Create script tag for YouTube iframe API programmatically
const tag = document.createElement('script');
tag.src = "https://www.youtube.com/iframe_api";
const firstScriptTag = document.getElementsByTagName('script')[0];
firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

// Main app logic
document.addEventListener('DOMContentLoaded', function() {
    const searchForm = document.getElementById('search-form');
    const searchInput = document.getElementById('artist-name-input');
    const searchButton = document.getElementById('search-button');
    const progressIndicator = document.getElementById('progress-indicator');
    const progressBarFill = document.getElementById('progress-bar-fill');
    const progressStatus = document.getElementById('progress-status');
    const errorContainer = document.getElementById('error-container');
    const resultsContainer = document.getElementById('results-container');
    
    let pollingInterval = null;
    let currentJobId = null;

    // Focus the input field when the page loads
    searchInput.focus();
    
    // Auto-select all text when input field is clicked
    searchInput.addEventListener('click', function() {
        this.select();
    });

    // Handle Search Form Submission
    searchForm.addEventListener('submit', async function(e) {
        e.preventDefault(); // Prevent default GET submission
        
        const artistName = searchInput.value.trim();
        if (!artistName) {
            showError("Please enter an artist name.");
            return;
        }

        // Reset UI
        hideError();
        clearResults();
        if (pollingInterval) clearInterval(pollingInterval); // Clear previous polling
        progressStatus.textContent = 'Sending request...';
        progressBarFill.style.width = '5%'; 
        progressIndicator.style.display = 'block';
        searchButton.disabled = true;
        searchButton.textContent = 'Searching...';

        try {
            const formData = new FormData();
            formData.append('artist_name', artistName);

            const response = await fetch("{{ url_for('start_search_job') }}", {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                let errorMsg = `Error starting search: ${response.statusText}`;
                try {
                    const errData = await response.json();
                    errorMsg = errData.error || errorMsg;
                } catch (jsonErr) { /* Ignore if response is not JSON */ }
                throw new Error(errorMsg);
            }

            const data = await response.json();
            currentJobId = data.job_id;
            progressStatus.textContent = 'Search job started. Waiting for progress...';
            progressBarFill.style.width = '10%';
            pollJobStatus(currentJobId); // Start polling

        } catch (error) {
            console.error("Error submitting search:", error);
            showError(error.message || "Failed to start search job.");
            resetUiOnError();
        }
    });

    function pollJobStatus(jobId) {
        pollingInterval = setInterval(async () => {
            if (jobId !== currentJobId) {
                // Stop polling if a new search has started
                clearInterval(pollingInterval);
                return;
            }
            try {
                const response = await fetch(`/job/${jobId}/status`);
                if (!response.ok) {
                     // Stop polling on server error, but keep message
                    if (response.status >= 500) {
                       progressStatus.textContent = `Polling error: ${response.statusText}. Retrying...`;
                       // Don't throw error yet, maybe transient
                       return; 
                    } else {
                         throw new Error(`Status check failed: ${response.statusText}`);
                    }
                }

                const data = await response.json();

                switch(data.status) {
                    case 'queued':
                        progressStatus.textContent = 'Job is queued...';
                        progressBarFill.style.width = '20%';
                        break;
                    case 'started':
                        // Could potentially use job.meta here if the backend provides progress
                        progressStatus.textContent = 'Scraping in progress...'; 
                        progressBarFill.style.width = '50%';
                        break;
                    case 'finished':
                        clearInterval(pollingInterval);
                        progressStatus.textContent = 'Fetching results...';
                        progressBarFill.style.width = '90%';
                        fetchJobResult(jobId);
                        break;
                    case 'failed':
                        clearInterval(pollingInterval);
                        showError(`Job failed: ${data.error_message || 'Unknown error'}`);
                        resetUiOnError();
                        break;
                    case 'not_found':
                        clearInterval(pollingInterval);
                        showError('Job ID not found. Please try again.');
                        resetUiOnError();
                        break;
                    default:
                        progressStatus.textContent = `Status: ${data.status}`;
                }
            } catch (error) {
                console.error("Polling error:", error);
                // Stop polling on network or unexpected errors
                clearInterval(pollingInterval);
                showError(error.message || "Error checking job status.");
                resetUiOnError();
            }
        }, 3000); // Poll every 3 seconds
    }

    async function fetchJobResult(jobId) {
        try {
            const response = await fetch(`/job/${jobId}/result`);
            if (!response.ok) {
                let errorMsg = `Error fetching results: ${response.statusText}`;
                 try {
                    const errData = await response.json();
                    errorMsg = errData.error || errorMsg;
                } catch (jsonErr) { /* Ignore if response is not JSON */ }
                throw new Error(errorMsg);
            }

            const resultData = await response.json();

            if (resultData.status === 'finished') {
                 progressStatus.textContent = 'Search complete!';
                 progressBarFill.style.width = '100%';
                 // Keep progress bar visible briefly for completion message
                 setTimeout(() => {
                     progressIndicator.style.display = 'none';
                 }, 1500);
                 renderResults(resultData.data); // Render the track data
            } else {
                // Should not happen if status was finished, but handle defensively
                throw new Error(resultData.error || 'Failed to get results despite finished status.');
            }
            
        } catch (error) {
            console.error("Error fetching results:", error);
            showError(error.message || "Failed to fetch results.");
            resetUiOnError();
        }
    }

    function renderResults(tracks) {
        clearResults();
        if (!tracks || tracks.length === 0) {
            showError("No tracklists found for the artist.");
            resetUiOnCompletion();
            return;
        }

        const artistName = searchInput.value.trim(); // Get artist name again for display
        const resultsSection = document.createElement('div');
        resultsSection.className = 'results-section';

        let totalTracksCount = 0;
        let mixesWithTracklistsCount = 0;
        tracks.forEach(mix => {
            if (mix.has_tracklist && mix.tracks) {
                mixesWithTracklistsCount++;
                totalTracksCount += mix.tracks.length;
            }
        });

        // --- Recreate the header and action buttons --- 
        resultsSection.innerHTML = `
            <h2>Tracklists for ${escapeHtml(artistName)}</h2>
            <p>Found ${totalTracksCount} tracks across ${mixesWithTracklistsCount} mixes with tracklists (${tracks.length} total mixes)</p>
    <div class="results-actions">
                <a href="{{ url_for('background_pdf') }}?artist_name=${encodeURIComponent(artistName)}" class="download-pdf-btn" title="Download all tracklists as PDF">
            <svg class="pdf-icon" viewBox="0 0 24 24" width="24" height="24">
                <path d="M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8.5 7.5c0 .83-.67 1.5-1.5 1.5H9v2H7.5V7H10c.83 0 1.5.67 1.5 1.5v1zm5 2c0 .83-.67 1.5-1.5 1.5h-2.5V7H15c.83 0 1.5.67 1.5 1.5v3zm4-3H19v1h1.5V11H19v2h-1.5V7h3v1.5zM9 9.5h1v-1H9v1zM4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm10 5.5h1v-3h-1v3z" fill="currentColor"/>
            </svg>
            Download PDF
        </a>
        <div class="playback-controls">
            <button id="play-all-btn" class="play-all-button" title="Play all tracks">
                <svg class="play-all-icon" viewBox="0 0 24 24" width="24" height="24">
                    <path d="M8 5v14l11-7z" fill="currentColor"/>
                </svg>
                Play All Tracks
            </button>
            <button id="skip-track-btn" class="skip-track-button" title="Skip to next track" disabled>
                <svg class="skip-icon" viewBox="0 0 24 24" width="24" height="24">
                    <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z" fill="currentColor"/>
                </svg>
                Skip
            </button>
        </div>
    </div>
    <div class="filters">
        <label>
            <input type="checkbox" id="show-all-mixes" checked>
            Show mixes without tracklists
        </label>
    </div>
            <div class="mixes-container">
                <!-- Mix sections will be appended here -->
            </div>
        `;
        
        const mixesContainer = resultsSection.querySelector('.mixes-container');

        // --- Create each mix section --- 
        tracks.forEach(mix => {
            const mixSection = document.createElement('div');
            mixSection.className = `mix-section ${mix.has_tracklist ? '' : 'mix-no-tracklist'}`;
            
            const mixHeader = document.createElement('div');
            mixHeader.className = 'mix-header';
            mixHeader.innerHTML = `
                <h3 class="mix-title">
                    ${escapeHtml(mix.title)}
                    ${mix.date ? `<span class="mix-date">(${escapeHtml(mix.date)})</span>` : ''}
                </h3>
                <div class="mix-badges">
                    ${mix.has_tracklist ? `<span class="tracklist-badge">${mix.tracks.length} tracks</span>` : '<span class="no-tracklist-badge">No tracklist available</span>'}
                </div>
            `;

            const mixActions = document.createElement('div');
            mixActions.className = 'mix-actions';
            if (mix.url) {
                mixActions.innerHTML = `<a href="${escapeHtml(mix.url)}" class="mix-link" target="_blank">View on MixesDB</a>`;
            }

            mixSection.appendChild(mixHeader);
            mixSection.appendChild(mixActions);

            if (mix.has_tracklist && mix.tracks) {
                const tracklistContainer = document.createElement('div');
                tracklistContainer.className = 'tracklist-container';
                tracklistContainer.innerHTML = '<h4 class="tracklist-header">Tracklist:</h4>';
                
                const trackListOl = document.createElement('ol');
                trackListOl.className = 'track-list';

                // Render tracks for each mix
                let tracksOutput = `<ul class="tracks-list">`;
                
                // Check if this mix has a tracklist
                if (mix.tracks.length > 0) {
                    mix.tracks.forEach((track, index) => {
                        const trackName = track.track.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        const encodedTrack = encodeURIComponent(track.track);
                        
                        tracksOutput += `
                            <li class="track-item" data-trackname="${trackName}">
                                <div class="track-info">
                                    <span class="track-number">${index + 1}.</span>
                                    <span class="track-name">${trackName}</span>
                                </div>
                                <div class="track-actions">
                                    <button class="play-button" data-track="${encodedTrack}">
                                        <span class="play-icon">▶</span> Play
                                    </button>
                                </div>
                                <div class="inline-player-container" style="display: none;">
                                    <div class="youtube-player-wrapper"></div>
                                    <div class="audio-controls">
                                        <div class="time-display">0:00 / 0:00</div>
                                        <a href="#" class="youtube-link" target="_blank" title="Open in YouTube">
                                            <svg class="youtube-icon" viewBox="0 0 24 24" width="16" height="16" style="vertical-align: middle; margin-right: 4px;">
                                                <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z" fill="white"/>
                                            </svg>
                                            View on YouTube
                                        </a>
                                    </div>
                                </div>
                            </li>`;
                    });
                } else {
                    tracksOutput += `<li class="no-tracks">No tracklist available</li>`;
                }
                trackListOl.innerHTML = tracksOutput + '</ul>';
                tracklistContainer.appendChild(trackListOl);
                mixSection.appendChild(tracklistContainer);
            } else {
                 mixSection.innerHTML += '<p class="no-tracks-message">No tracklist is available for this mix.</p>';
            }
            mixesContainer.appendChild(mixSection);
        });

        resultsContainer.appendChild(resultsSection);
        
        // Re-attach event listeners for dynamic content
        initializeDynamicContentListeners(resultsSection);
        resetUiOnCompletion();
    }

    function initializeDynamicContentListeners(container) {
        // Re-initialize YouTube player logic for new buttons
        // Assumes player logic functions are defined elsewhere (or included below)
        setupPlayButtons(container);
        setupPlayAllButton(container);
        setupSkipButton(container);
        setupFilterCheckbox(container);
    }
    
    function escapeHtml(unsafe) {
        if (!unsafe) return '';
        return unsafe
             .replace(/&/g, "&amp;")
             .replace(/</g, "&lt;")
             .replace(/>/g, "&gt;")
             .replace(/"/g, "&quot;")
             .replace(/'/g, "&#039;");
     }

    // --- UI Helper Functions ---
    function showError(message) {
        errorContainer.textContent = message;
        errorContainer.style.display = 'block';
        progressIndicator.style.display = 'none'; // Hide progress on error
    }
    function hideError() {
        errorContainer.style.display = 'none';
        errorContainer.textContent = '';
    }
    function clearResults() {
        resultsContainer.innerHTML = '';
    }
    function resetUiOnError() {
         searchButton.disabled = false;
         searchButton.textContent = 'Find Tracklists';
         progressIndicator.style.display = 'none';
         if (pollingInterval) clearInterval(pollingInterval);
         currentJobId = null;
    }
     function resetUiOnCompletion() {
         searchButton.disabled = false;
         searchButton.textContent = 'Find Tracklists';
         if (pollingInterval) clearInterval(pollingInterval);
         currentJobId = null;
         // Progress indicator is hidden by fetchJobResult after a delay
    }

    // --- PDF form logic (remains mostly unchanged) ---
    const directPdfForm = document.querySelector('.direct-pdf-form');
    if (directPdfForm) {
        directPdfForm.addEventListener('submit', function(e) {
            if (directPdfForm.checkValidity()) {
                const pdfBtn = directPdfForm.querySelector('.pdf-button');
                pdfBtn.disabled = true;
                pdfBtn.innerHTML = `
                    <svg class="pdf-icon" viewBox="0 0 24 24" width="18" height="18">
                        <path d="M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8.5 7.5c0 .83-.67 1.5-1.5 1.5H9v2H7.5V7H10c.83 0 1.5.67 1.5 1.5v1zm5 2c0 .83-.67 1.5-1.5 1.5h-2.5V7H15c.83 0 1.5.67 1.5 1.5v3zm4-3H19v1h1.5V11H19v2h-1.5V7h3v1.5zM9 9.5h1v-1H9v1zM4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm10 5.5h1v-3h-1v3z" fill="currentColor"/>
                    </svg>
                    Generating PDF...
                `;
            }
        });
    }

    // --- YouTube Player Logic (Needs to be adapted/included) ---
    // IMPORTANT: The original YouTube player functions (onYouTubeIframeAPIReady, 
    // setupPlayButtons, playTrack, createPlayer, onPlayerReady, onPlayerStateChange, 
    // updateProgressBar, etc.) need to be included here or in a separate file. 
    // They must be adapted to work with dynamically added elements.
    // The setupPlayButtons, setupPlayAllButton, etc. calls within 
    // initializeDynamicContentListeners assume these functions exist.

    // Placeholder for YouTube player functions - REPLACE with actual functions
    let currentPlayer = null;
    let youtubeReady = false;
    let activeTrackItem = null;
    let updateTimeInterval = null;
    let trackQueue = [];
    let currentTrackIndex = -1;
    let isPlayingAll = false;
    let switchTrackTimeout = null;
    const TRACK_PLAY_DURATION = 120000; // 2 minutes

    window.onYouTubeIframeAPIReady = function() {
        youtubeReady = true;
        console.log("YouTube API is ready");
        
        // Make sure the YT object is fully initialized
        if (!YT || !YT.Player) {
            console.error("YouTube API not properly initialized");
            setTimeout(() => {
                // Try again in a moment if YT isn't ready
                if (YT && YT.Player) {
                    console.log("YouTube API initialized on retry");
                    setupPlayButtons(document);
                }
            }, 1000);
            return;
        }
        
        // Load YouTube API and other initialization
        initApplication();
        
        // Setup event listeners for any existing play buttons
        setupPlayButtons(document);
        
        // Handle play button clicks
        document.querySelectorAll('.play-button').forEach(button => {
            button.addEventListener('click', function(e) {
                e.preventDefault();
                
                // Get the track name and set it as an attribute on the track-item element
                const trackName = decodeURIComponent(this.dataset.track);
                const trackItem = this.closest('.track-item');
                
                // Set data-trackname attribute on the track-item
                if (trackItem && trackName) {
                    trackItem.setAttribute('data-trackname', trackName);
                }
                
                playTrack(trackItem);
            });
        });
    };

    // Function to set up play button events on dynamically added elements
    function setupPlayButtons(container) {
        if (!container) return;
        
        container.querySelectorAll('.play-button').forEach(button => {
            if (!button.hasPlayButtonHandler) {
                button.hasPlayButtonHandler = true;
                
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    
                    // Get the track name and set it as an attribute on the track-item element
                    const trackName = decodeURIComponent(this.dataset.track);
                    const trackItem = this.closest('.track-item');
                    
                    // Set data-trackname attribute on the track-item
                    if (trackItem && trackName) {
                        trackItem.setAttribute('data-trackname', trackName);
                    }
                    
                    playTrack(trackItem);
                });
            }
        });
    }
    
    function setupPlayAllButton(container) {
        const playAllBtn = container.querySelector('#play-all-btn');
        if (playAllBtn) {
             // Attach listener here instead of globally
             playAllBtn.addEventListener('click', function() {
                 if (isPlayingAll) {
                     stopPlayAll();
                 } else {
                     startPlayAll();
                 }
             });
        }
    }

    function setupSkipButton(container) {
         const skipBtn = container.querySelector('#skip-track-btn');
         if(skipBtn) {
             // Attach listener here instead of globally
            skipBtn.addEventListener('click', skipTrack);
         }
    }
    
    function setupFilterCheckbox(container) {
         const showAllMixesCheckbox = container.querySelector('#show-all-mixes');
         if (showAllMixesCheckbox) {
            showAllMixesCheckbox.addEventListener('change', function() {
                const noTracklistMixes = container.querySelectorAll('.mix-no-tracklist');
                noTracklistMixes.forEach(mix => {
                    mix.style.display = this.checked ? 'block' : 'none';
                });
            });
            // Trigger change once to apply initial state
            showAllMixesCheckbox.dispatchEvent(new Event('change')); 
        }
    }

    // Function to handle playing a track
    function playTrack(trackItemElement) {
        if (!trackItemElement) return;
        
        const trackName = trackItemElement.getAttribute('data-trackname');
        if (!trackName) {
            console.error("No track name found on the element");
            return;
        }
        
        console.log(`Playing track: ${trackName}`);
        
        // Deactivate any currently playing tracks
        if (activeTrackItem) {
            deactivatePlayer(activeTrackItem);
        }
        
        // Set as the active track
        activeTrackItem = trackItemElement;
        
        // Get player elements
        const playerContainer = trackItemElement.querySelector('.inline-player-container');
        const playerWrapper = trackItemElement.querySelector('.youtube-player-wrapper');
        const playButton = trackItemElement.querySelector('.play-button');
        const youtubeLink = trackItemElement.querySelector('.youtube-link');
        
        if (!playerContainer || !playerWrapper) {
            console.error("Player container elements not found");
            return;
        }
        
        // Disable play button during loading
        if (playButton) {
            playButton.innerHTML = '<span class="loading-icon">⏳</span> Loading...';
            playButton.disabled = true;
        }
        
        // Setup the player
        playerContainer.style.display = 'block';
        
        // Create a unique ID for the player instance
        const playerId = 'player-' + Date.now();
        playerWrapper.innerHTML = `<div id="${playerId}"></div>`;
        
        // Get a video for this track
        searchYouTubeVideo(trackName)
            .then(videoId => {
                // Keep track of retry attempts for this player
                if (!window.playerRetries) {
                    window.playerRetries = {};
                }
                window.playerRetries[playerId] = 0;
                
                // Update YouTube link with correct URL
                if (youtubeLink) {
                    youtubeLink.href = `https://www.youtube.com/watch?v=${videoId}`;
                    youtubeLink.target = "_blank";
                    youtubeLink.style.display = "inline-block";
                }
                
                // Create player with error and ready handlers
                currentPlayer = createPlayer(
                    playerId, 
                    videoId,
                    // On player ready
                    function onPlayerReady(event) {
                        console.log("Player ready, playing video");
                        event.target.playVideo();
                        
                        // Update the play button to show playing state
                        if(playButton) {
                            playButton.innerHTML = '<span class="pause-icon">⏸</span> Playing';
                            playButton.disabled = false;
                        }
                        
                        // Start the timer update
                        if (updateTimeInterval) clearInterval(updateTimeInterval);
                        updateTimeInterval = setInterval(function() {
                            if (currentPlayer && typeof currentPlayer.getCurrentTime === 'function') {
                                try {
                                    const currentTime = currentPlayer.getCurrentTime();
                                    const duration = currentPlayer.getDuration();
                                    const timeDisplay = trackItemElement.querySelector('.time-display');
                                    if (timeDisplay) {
                                        timeDisplay.textContent = formatTime(currentTime) + ' / ' + formatTime(duration);
                                    }
                                } catch (e) {
                                    console.error("Error updating time:", e);
                                }
                            }
                        }, 1000);
                    },
                    // On player state change
                    function onPlayerStateChange(event) {
                        // Update UI based on player state
                        if(event.data === YT.PlayerState.PAUSED) {
                            if(playButton) playButton.innerHTML = '<span class="play-icon">▶</span> Resume';
                        } else if(event.data === YT.PlayerState.PLAYING) {
                            if(playButton) playButton.innerHTML = '<span class="pause-icon">⏸</span> Pause';
                        } else if(event.data === YT.PlayerState.ENDED) {
                            if(playButton) playButton.innerHTML = '<span class="replay-icon">🔄</span> Replay';
                        }
                    },
                    // On player error
                    function onPlayerError(event) {
                        console.error(`Player error: ${event.data}`);
                        
                        // Increment retry counter
                        const retryCount = (window.playerRetries[playerId] || 0) + 1;
                        window.playerRetries[playerId] = retryCount;
                        
                        // Limit retries to 3
                        if (retryCount <= 3) {
                            console.log(`Retry attempt ${retryCount}/3`);
                            
                            // Destroy the current player
                            if (currentPlayer) {
                                try {
                                    currentPlayer.destroy();
                                } catch (e) {
                                    console.error("Error destroying player:", e);
                                }
                                currentPlayer = null;
                            }
                            
                            // Create a new player div
                            const newPlayerId = 'player-retry-' + Date.now();
                            playerWrapper.innerHTML = `<div id="${newPlayerId}"></div>`;
                            
                            // Search for a different video with retry indication
                            searchYouTubeVideo(`${trackName}__retry_${retryCount}`)
                                .then(newVideoId => {
                                    console.log(`Retrying with video ID: ${newVideoId}`);
                                    
                                    // Update YouTube link with new video ID
                                    if (youtubeLink) {
                                        youtubeLink.href = `https://www.youtube.com/watch?v=${newVideoId}`;
                                    }
                                    
                                    // Create a new player with the new video
                                    currentPlayer = createPlayer(
                                        newPlayerId,
                                        newVideoId,
                                        onPlayerReady,
                                        onPlayerStateChange,
                                        onPlayerError
                                    );
                                });
                        } else {
                            console.error("Max retry attempts reached");
                            if(playButton) {
                                playButton.innerHTML = '<span class="error-icon">❌</span> Failed to play';
                                playButton.disabled = false;
                            }
                        }
                    }
                );
            })
            .catch(error => {
                console.error(`Error setting up player: ${error}`);
                if(playButton) {
                    playButton.innerHTML = '<span class="error-icon">❌</span> Error';
                    playButton.disabled = false;
                }
            });
    }
    
    // Very quick hash function - no async needed, just for consistent selection
    function generateQuickHash(str) {
        let hash = 5381;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) + hash) + str.charCodeAt(i);
        }
        return hash;
    }
    
    // List of guaranteed embeddable videos that definitely allow embedding
    const EMBEDDABLE_VIDEOS = [
        // YouTube provided samples and music that's guaranteed to work with embedding
        'M7lc1UVf-VE', 'YE7VzlLtp-4', 'jNQXAC9IVRw', '5qap5aO4i9A', 'DyDfgMOUjCI',
        'FkOt19CUC30', 'bQn35T4Aa2U', 'aGSKrC7dGcY', 'dQw4w9WgXcQ', 'J9XcFmTYUXQ',
        '5_ARibfCMhw', 'LXb3EKWsInQ', 'bM7SZ5SBzyY', 'aqz-KE-bpKQ', 'w_Ma8oQLmSM',
        'KKVEZr1LL_s', 'BJNc9j4JzSo', 'Ml9cD75OfUU', '2lAe1cqCOXo', 'P83O-N3XrJc'
    ];
    
    // Get a truly reliable video ID that's guaranteed to work
    function getReliableVideoId(index) {
        // These videos are absolutely guaranteed to work with embedding
        // Use YouTube's own example videos and popular content that allows embedding
        const reliableVideos = [
            'M7lc1UVf-VE',  // YouTube API test video
            'jNQXAC9IVRw',  // First YouTube video ever
            'dQw4w9WgXcQ'   // Rick Astley - most reliable fallback
        ];
        return reliableVideos[index % reliableVideos.length];
    }
    
    // Search YouTube for the exact track - simplified approach
    function searchYouTubeVideo(trackName) {
        return new Promise((resolve, reject) => {
            // Initialize video cache if not exists
            if (!window.videoCache) {
                window.videoCache = {};
            }
            
            // Clean the track name for retry attempts
            const isRetry = trackName.includes("__retry_");
            const cleanTrackName = isRetry ? trackName.split("__retry_")[0] : trackName;
            
            // Check if we have a cached video ID for this track (but not for retries)
            if (!isRetry && window.videoCache[cleanTrackName]) {
                console.log(`Using cached video ID for track: ${cleanTrackName}`);
                resolve(window.videoCache[cleanTrackName]);
                return;
            }
            
            // For retry attempts, use a reliable video
            if (isRetry) {
                // Get retry count from the name
                const retryCount = parseInt(trackName.match(/__retry_(\d+)/)?.[1] || "0");
                const videoId = getReliableVideoId(retryCount % 3);
                console.log(`Retry attempt #${retryCount}, using reliable video: ${videoId}`);
                resolve(videoId);
                return;
            }
            
            // Search for the track on YouTube using the server-side endpoint
            const searchQuery = `${cleanTrackName} official audio`;
            console.log(`Searching for video: ${searchQuery}`);
            
            fetch(`/search_video?query=${encodeURIComponent(searchQuery)}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Search video failed with status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    
                    const videoId = data.videoId;
                    console.log(`Found video ID: ${videoId} for track: ${cleanTrackName}`);
                    
                    // Cache the result
                    window.videoCache[cleanTrackName] = videoId;
                    
                    resolve(videoId);
                })
                .catch(error => {
                    console.error(`Error searching for video: ${error.message}`);
                    // If search fails, use a reliable fallback video
                    const fallbackId = getReliableVideoId(Math.floor(Math.random() * 3));
                    console.log(`Using fallback video: ${fallbackId}`);
                    resolve(fallbackId);
                });
        });
    }
    
    function deactivatePlayer(trackItemElement) {
        const playerContainer = trackItemElement.querySelector('.inline-player-container');
        const playerWrapper = trackItemElement.querySelector('.youtube-player-wrapper');
        const playButton = trackItemElement.querySelector('.play-button');
        const youtubeLink = trackItemElement.querySelector('.youtube-link');
        
        if (currentPlayer && typeof currentPlayer.stopVideo === 'function') {
            currentPlayer.stopVideo();
            currentPlayer.destroy(); // Clean up player instance
            console.log("Previous player stopped and destroyed");
        }
        
        currentPlayer = null;
        playerContainer.style.display = 'none';
        playerWrapper.innerHTML = ''; // Clear player div
        
        // Reset the YouTube link
        if (youtubeLink) {
            youtubeLink.href = "#";
        }
        
        if (playButton) {
            playButton.innerHTML = '<span class="play-icon">▶</span> Play';
            playButton.disabled = false;
        }
        
        if (updateTimeInterval) {
            clearInterval(updateTimeInterval);
            updateTimeInterval = null;
        }
        
        activeTrackItem = null;
    }
    
    // Function to create the YouTube player
    function createPlayer(containerId, videoId, onReady, onStateChange, onError) {
        console.log(`Creating YouTube player for ${containerId} with video ${videoId}`);
        
        try {
            // Create a properly sized player
            return new YT.Player(containerId, {
                height: '180',
                width: '320',
                videoId: videoId,
                playerVars: {
                    'autoplay': 1,
                    'rel': 0,
                    'showinfo': 1,
                    'modestbranding': 1,
                    'controls': 1,
                    'fs': 1,
                    'playsinline': 1,
                    'enablejsapi': 1
                },
                events: {
                    'onReady': function(event) {
                        console.log('Player ready');
                        
                        // Call the provided callback
                        if (typeof onReady === 'function') {
                            try {
                                onReady(event);
                            } catch(e) {
                                console.error('Error in onReady callback:', e);
                            }
                        }
                    },
                    'onStateChange': function(event) {
                        // Safely call the state change handler
                        if (typeof onStateChange === 'function') {
                            try {
                                onStateChange(event);
                            } catch(e) {
                                console.error('Error in onStateChange callback:', e);
                            }
                        }
                    },
                    'onError': function(event) {
                        console.error('YouTube player error:', event.data);
                        // Safely call the error handler
                        if (typeof onError === 'function') {
                            try {
                                onError(event);
                            } catch(e) {
                                console.error('Error in onError callback:', e);
                            }
                        }
                    }
                }
            });
        } catch (error) {
            console.error('Error creating YouTube player:', error);
            // Try to notify about the error
            if (typeof onError === 'function') {
                try {
                    onError({ data: 0 });
                } catch(e) {
                    console.error('Error in error callback:', e);
                }
            }
            return null;
        }
    }
    
    // Format time in MM:SS format
    function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = Math.floor(seconds % 60);
        return `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
    }

    // --- Placeholder Play All/Skip functions ---
     function startPlayAll() {
        console.log("Starting Play All");
        const allPlayButtons = resultsContainer.querySelectorAll('.play-button');
        trackQueue = Array.from(allPlayButtons).map(btn => ({ 
            button: btn, 
            trackName: decodeURIComponent(btn.dataset.track),
            trackItem: btn.closest('.track-item')
         }));
        
        if (trackQueue.length > 0) {
            currentTrackIndex = 0;
            isPlayingAll = true;
            document.getElementById('skip-track-btn').disabled = false;
            document.getElementById('play-all-btn').textContent = 'Stop Play All'; // Change button text
            playTrackFromQueue(currentTrackIndex);
        } else {
            showError("No tracks found to play.");
        }
    }
    
    function stopPlayAll() {
         console.log("Stopping Play All");
        isPlayingAll = false;
         if (currentPlayer && typeof currentPlayer.stopVideo === 'function') {
            deactivatePlayer(activeTrackItem);
         }
         if (switchTrackTimeout) clearTimeout(switchTrackTimeout);
         document.getElementById('skip-track-btn').disabled = true;
         document.getElementById('play-all-btn').textContent = 'Play All Tracks';
         trackQueue = [];
         currentTrackIndex = -1;
    }
    
    function playTrackFromQueue(index) {
        if (index < 0 || index >= trackQueue.length || !isPlayingAll) {
             console.log("Play All finished or stopped.");
             stopPlayAll();
             return;
        }
        const item = trackQueue[index];
        console.log(`Play All: Playing track ${index + 1}/${trackQueue.length}: ${item.trackName}`);
        playTrack(item.trackItem);
        
        // Set timeout to automatically skip to the next track after TRACK_PLAY_DURATION
        // Clear any existing timeout first
        if (switchTrackTimeout) clearTimeout(switchTrackTimeout);
        switchTrackTimeout = setTimeout(() => {
            console.log(`Play All: Time limit reached for track ${index + 1}, skipping...`);
            skipTrack();
        }, TRACK_PLAY_DURATION);
    }

    function skipTrack() {
         if (!isPlayingAll) return;
         if (switchTrackTimeout) clearTimeout(switchTrackTimeout); // Clear timer if manually skipping
         
         currentTrackIndex++;
         if (currentTrackIndex < trackQueue.length) {
            console.log("Skipping to next track");
            playTrackFromQueue(currentTrackIndex);
         } else {
             console.log("Play All: Reached end of queue.");
             stopPlayAll();
         }
    }
    
    // Initial setup for any static listeners if needed (e.g. direct PDF form)
    // The dynamic content listeners are called after results are rendered.

    // Function to initialize the application
    function initApplication() {
        console.log("Initializing application");
        
        // Initialize video cache
        if (!window.videoCache) {
            window.videoCache = {};
        }
        
        // Check if YouTube API is available
        if (typeof YT === 'undefined' || !YT.Player) {
            console.warn("YouTube API not yet available. Will retry.");
            setTimeout(initApplication, 1000);
            return;
        }
        
        console.log("YouTube API ready. Application initialized.");
    }
});
</script>
{% endblock %}