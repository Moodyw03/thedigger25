{% extends 'base.html' %}

{% block title %}The Digger - Find DJ Tracklists{% endblock %}

{% block content %}
<div class="search-section">
    <form id="search-form" class="search-form">
        <input type="text" id="artist-name-input" name="artist_name" value="{{ artist_name if artist_name else '' }}" placeholder="Enter artist name (e.g., Ben UFO)" required>
        <button type="submit" id="search-button">Find Tracklists</button>
    </form>
    
    <div id="progress-indicator" class="progress-bar-container" style="display: none;">
        <div class="progress-bar">
            <div class="progress-bar-fill" id="progress-bar-fill"></div>
        </div>
        <p class="progress-status" id="progress-status">Starting search...</p>
    </div>

    <div id="error-container" class="error" style="display: none;"></div>

    <div id="results-container">
        <!-- Results will be dynamically injected here -->
        <!-- Keep existing structure for PDF download etc if needed outside results -->
    </div>
    
    <div class="search-options">
        <span class="search-options-text">Or get a PDF directly:</span>
        <form action="{{ url_for('background_pdf') }}" method="get" class="direct-pdf-form">
            <input type="text" name="artist_name" placeholder="Enter artist name" required>
            <button type="submit" class="pdf-button">
                <svg class="pdf-icon" viewBox="0 0 24 24" width="18" height="18">
                    <path d="M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8.5 7.5c0 .83-.67 1.5-1.5 1.5H9v2H7.5V7H10c.83 0 1.5.67 1.5 1.5v1zm5 2c0 .83-.67 1.5-1.5 1.5h-2.5V7H15c.83 0 1.5.67 1.5 1.5v3zm4-3H19v1h1.5V11H19v2h-1.5V7h3v1.5zM9 9.5h1v-1H9v1zM4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm10 5.5h1v-3h-1v3z" fill="currentColor"/>
                </svg>
                Download PDF
            </button>
        </form>
        <p class="direct-pdf-hint">Works with both small and large catalogs using background processing</p>
    </div>
</div>

{% endblock %}

{% block scripts %}
<script>
// Create script tag for YouTube iframe API programmatically
const tag = document.createElement('script');
tag.src = "https://www.youtube.com/iframe_api";
const firstScriptTag = document.getElementsByTagName('script')[0];
firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

// Main app logic
document.addEventListener('DOMContentLoaded', function() {
    const searchForm = document.getElementById('search-form');
    const searchInput = document.getElementById('artist-name-input');
    const searchButton = document.getElementById('search-button');
    const progressIndicator = document.getElementById('progress-indicator');
    const progressBarFill = document.getElementById('progress-bar-fill');
    const progressStatus = document.getElementById('progress-status');
    const errorContainer = document.getElementById('error-container');
    const resultsContainer = document.getElementById('results-container');
    
    let pollingInterval = null;
    let currentJobId = null;

    // Focus the input field when the page loads
    searchInput.focus();
    
    // Auto-select all text when input field is clicked
    searchInput.addEventListener('click', function() {
        this.select();
    });

    // Handle Search Form Submission
    searchForm.addEventListener('submit', async function(e) {
        e.preventDefault(); // Prevent default GET submission
        
        const artistName = searchInput.value.trim();
        if (!artistName) {
            showError("Please enter an artist name.");
            return;
        }

        // Reset UI
        hideError();
        clearResults();
        if (pollingInterval) clearInterval(pollingInterval); // Clear previous polling
        progressStatus.textContent = 'Sending request...';
        progressBarFill.style.width = '5%'; 
        progressIndicator.style.display = 'block';
        searchButton.disabled = true;
        searchButton.textContent = 'Searching...';

        try {
            const formData = new FormData();
            formData.append('artist_name', artistName);

            const response = await fetch("{{ url_for('start_search_job') }}", {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                let errorMsg = `Error starting search: ${response.statusText}`;
                try {
                    const errData = await response.json();
                    errorMsg = errData.error || errorMsg;
                } catch (jsonErr) { /* Ignore if response is not JSON */ }
                throw new Error(errorMsg);
            }

            const data = await response.json();
            currentJobId = data.job_id;
            progressStatus.textContent = 'Search job started. Waiting for progress...';
            progressBarFill.style.width = '10%';
            pollJobStatus(currentJobId); // Start polling

        } catch (error) {
            console.error("Error submitting search:", error);
            showError(error.message || "Failed to start search job.");
            resetUiOnError();
        }
    });

    function pollJobStatus(jobId) {
        pollingInterval = setInterval(async () => {
            if (jobId !== currentJobId) {
                // Stop polling if a new search has started
                clearInterval(pollingInterval);
                return;
            }
            try {
                const response = await fetch(`/job/${jobId}/status`);
                if (!response.ok) {
                     // Stop polling on server error, but keep message
                    if (response.status >= 500) {
                       progressStatus.textContent = `Polling error: ${response.statusText}. Retrying...`;
                       // Don't throw error yet, maybe transient
                       return; 
                    } else {
                         throw new Error(`Status check failed: ${response.statusText}`);
                    }
                }

                const data = await response.json();

                switch(data.status) {
                    case 'queued':
                        progressStatus.textContent = 'Job is queued...';
                        progressBarFill.style.width = '20%';
                        break;
                    case 'started':
                        // Could potentially use job.meta here if the backend provides progress
                        progressStatus.textContent = 'Scraping in progress...'; 
                        progressBarFill.style.width = '50%';
                        break;
                    case 'finished':
                        clearInterval(pollingInterval);
                        progressStatus.textContent = 'Fetching results...';
                        progressBarFill.style.width = '90%';
                        fetchJobResult(jobId);
                        break;
                    case 'failed':
                        clearInterval(pollingInterval);
                        showError(`Job failed: ${data.error_message || 'Unknown error'}`);
                        resetUiOnError();
                        break;
                    case 'not_found':
                        clearInterval(pollingInterval);
                        showError('Job ID not found. Please try again.');
                        resetUiOnError();
                        break;
                    default:
                        progressStatus.textContent = `Status: ${data.status}`;
                }
            } catch (error) {
                console.error("Polling error:", error);
                // Stop polling on network or unexpected errors
                clearInterval(pollingInterval);
                showError(error.message || "Error checking job status.");
                resetUiOnError();
            }
        }, 3000); // Poll every 3 seconds
    }

    async function fetchJobResult(jobId) {
        try {
            const response = await fetch(`/job/${jobId}/result`);
            if (!response.ok) {
                let errorMsg = `Error fetching results: ${response.statusText}`;
                 try {
                    const errData = await response.json();
                    errorMsg = errData.error || errorMsg;
                } catch (jsonErr) { /* Ignore if response is not JSON */ }
                throw new Error(errorMsg);
            }

            const resultData = await response.json();

            if (resultData.status === 'finished') {
                 progressStatus.textContent = 'Search complete!';
                 progressBarFill.style.width = '100%';
                 // Keep progress bar visible briefly for completion message
                 setTimeout(() => {
                     progressIndicator.style.display = 'none';
                 }, 1500);
                 renderResults(resultData.data); // Render the track data
            } else {
                // Should not happen if status was finished, but handle defensively
                throw new Error(resultData.error || 'Failed to get results despite finished status.');
            }
            
        } catch (error) {
            console.error("Error fetching results:", error);
            showError(error.message || "Failed to fetch results.");
            resetUiOnError();
        }
    }

    function renderResults(tracks) {
        clearResults();
        if (!tracks || tracks.length === 0) {
            showError("No tracklists found for the artist.");
            resetUiOnCompletion();
            return;
        }

        const artistName = searchInput.value.trim(); // Get artist name again for display
        const resultsSection = document.createElement('div');
        resultsSection.className = 'results-section';

        let totalTracksCount = 0;
        let mixesWithTracklistsCount = 0;
        tracks.forEach(mix => {
            if (mix.has_tracklist && mix.tracks) {
                mixesWithTracklistsCount++;
                totalTracksCount += mix.tracks.length;
            }
        });

        // --- Recreate the header and action buttons --- 
        resultsSection.innerHTML = `
            <h2>Tracklists for ${escapeHtml(artistName)}</h2>
            <p>Found ${totalTracksCount} tracks across ${mixesWithTracklistsCount} mixes with tracklists (${tracks.length} total mixes)</p>
    <div class="results-actions">
                <a href="{{ url_for('background_pdf') }}?artist_name=${encodeURIComponent(artistName)}" class="download-pdf-btn" title="Download all tracklists as PDF">
            <svg class="pdf-icon" viewBox="0 0 24 24" width="24" height="24">
                <path d="M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8.5 7.5c0 .83-.67 1.5-1.5 1.5H9v2H7.5V7H10c.83 0 1.5.67 1.5 1.5v1zm5 2c0 .83-.67 1.5-1.5 1.5h-2.5V7H15c.83 0 1.5.67 1.5 1.5v3zm4-3H19v1h1.5V11H19v2h-1.5V7h3v1.5zM9 9.5h1v-1H9v1zM4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm10 5.5h1v-3h-1v3z" fill="currentColor"/>
            </svg>
            Download PDF
        </a>
        <div class="playback-controls">
            <button id="play-all-btn" class="play-all-button" title="Play all tracks">
                <svg class="play-all-icon" viewBox="0 0 24 24" width="24" height="24">
                    <path d="M8 5v14l11-7z" fill="currentColor"/>
                </svg>
                Play All Tracks
            </button>
            <button id="skip-track-btn" class="skip-track-button" title="Skip to next track" disabled>
                <svg class="skip-icon" viewBox="0 0 24 24" width="24" height="24">
                    <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z" fill="currentColor"/>
                </svg>
                Skip
            </button>
        </div>
    </div>
    <div class="filters">
        <label>
            <input type="checkbox" id="show-all-mixes" checked>
            Show mixes without tracklists
        </label>
    </div>
            <div class="mixes-container">
                <!-- Mix sections will be appended here -->
            </div>
        `;
        
        const mixesContainer = resultsSection.querySelector('.mixes-container');

        // --- Create each mix section --- 
        tracks.forEach(mix => {
            const mixSection = document.createElement('div');
            mixSection.className = `mix-section ${mix.has_tracklist ? '' : 'mix-no-tracklist'}`;
            
            const mixHeader = document.createElement('div');
            mixHeader.className = 'mix-header';
            mixHeader.innerHTML = `
                <h3 class="mix-title">
                    ${escapeHtml(mix.title)}
                    ${mix.date ? `<span class="mix-date">(${escapeHtml(mix.date)})</span>` : ''}
                </h3>
                <div class="mix-badges">
                    ${mix.has_tracklist ? `<span class="tracklist-badge">${mix.tracks.length} tracks</span>` : '<span class="no-tracklist-badge">No tracklist available</span>'}
                </div>
            `;

            const mixActions = document.createElement('div');
            mixActions.className = 'mix-actions';
            if (mix.url) {
                mixActions.innerHTML = `<a href="${escapeHtml(mix.url)}" class="mix-link" target="_blank">View on MixesDB</a>`;
            }

            mixSection.appendChild(mixHeader);
            mixSection.appendChild(mixActions);

            if (mix.has_tracklist && mix.tracks) {
                const tracklistContainer = document.createElement('div');
                tracklistContainer.className = 'tracklist-container';
                tracklistContainer.innerHTML = '<h4 class="tracklist-header">Tracklist:</h4>';
                
                const trackListOl = document.createElement('ol');
                trackListOl.className = 'track-list';

                mix.tracks.forEach(track => {
                    const trackLi = document.createElement('li');
                    trackLi.className = 'track-item';
                    trackLi.innerHTML = `
                        <div class="track-info">
                            <span class="track-name">${escapeHtml(track.track)}</span>
                            <button class="play-button" data-track="${encodeURIComponent(track.track)}" title="Play track">
                                <span class="play-icon">▶</span> Play
                            </button>
                        </div>
                        <div class="inline-player-container" style="display: none;">
                            <div class="player-controls">
                                <div class="audio-controls">
                                    <span class="control-btn play-pause-btn">⏸</span>
                                    <span class="time-display">0:00</span>
                                    <a href="#" class="youtube-link" target="_blank" title="View on YouTube">
                                        <svg class="youtube-icon" viewBox="0 0 24 24" width="22" height="22">
                                            <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z" fill="#ff0000"/>
                                        </svg>
                                    </a>
                                </div>
                                <div class="youtube-player-wrapper">
                                    <!-- YouTube player will be inserted here -->
                                </div>
                            </div>
                        </div>
                    `;
                    trackListOl.appendChild(trackLi);
                });
                tracklistContainer.appendChild(trackListOl);
                mixSection.appendChild(tracklistContainer);
            } else {
                 mixSection.innerHTML += '<p class="no-tracks-message">No tracklist is available for this mix.</p>';
            }
            mixesContainer.appendChild(mixSection);
        });

        resultsContainer.appendChild(resultsSection);
        
        // Re-attach event listeners for dynamic content
        initializeDynamicContentListeners(resultsSection);
        resetUiOnCompletion();
    }

    function initializeDynamicContentListeners(container) {
        // Re-initialize YouTube player logic for new buttons
        // Assumes player logic functions are defined elsewhere (or included below)
        setupPlayButtons(container);
        setupPlayAllButton(container);
        setupSkipButton(container);
        setupFilterCheckbox(container);
    }
    
    function escapeHtml(unsafe) {
        if (!unsafe) return '';
        return unsafe
             .replace(/&/g, "&amp;")
             .replace(/</g, "&lt;")
             .replace(/>/g, "&gt;")
             .replace(/"/g, "&quot;")
             .replace(/'/g, "&#039;");
     }

    // --- UI Helper Functions ---
    function showError(message) {
        errorContainer.textContent = message;
        errorContainer.style.display = 'block';
        progressIndicator.style.display = 'none'; // Hide progress on error
    }
    function hideError() {
        errorContainer.style.display = 'none';
        errorContainer.textContent = '';
    }
    function clearResults() {
        resultsContainer.innerHTML = '';
    }
    function resetUiOnError() {
         searchButton.disabled = false;
         searchButton.textContent = 'Find Tracklists';
         progressIndicator.style.display = 'none';
         if (pollingInterval) clearInterval(pollingInterval);
         currentJobId = null;
    }
     function resetUiOnCompletion() {
         searchButton.disabled = false;
         searchButton.textContent = 'Find Tracklists';
         if (pollingInterval) clearInterval(pollingInterval);
         currentJobId = null;
         // Progress indicator is hidden by fetchJobResult after a delay
    }

    // --- PDF form logic (remains mostly unchanged) ---
    const directPdfForm = document.querySelector('.direct-pdf-form');
    if (directPdfForm) {
        directPdfForm.addEventListener('submit', function(e) {
            if (directPdfForm.checkValidity()) {
                const pdfBtn = directPdfForm.querySelector('.pdf-button');
                pdfBtn.disabled = true;
                pdfBtn.innerHTML = `
                    <svg class="pdf-icon" viewBox="0 0 24 24" width="18" height="18">
                        <path d="M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8.5 7.5c0 .83-.67 1.5-1.5 1.5H9v2H7.5V7H10c.83 0 1.5.67 1.5 1.5v1zm5 2c0 .83-.67 1.5-1.5 1.5h-2.5V7H15c.83 0 1.5.67 1.5 1.5v3zm4-3H19v1h1.5V11H19v2h-1.5V7h3v1.5zM9 9.5h1v-1H9v1zM4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm10 5.5h1v-3h-1v3z" fill="currentColor"/>
                    </svg>
                    Generating PDF...
                `;
            }
        });
    }

    // --- YouTube Player Logic (Needs to be adapted/included) ---
    // IMPORTANT: The original YouTube player functions (onYouTubeIframeAPIReady, 
    // setupPlayButtons, playTrack, createPlayer, onPlayerReady, onPlayerStateChange, 
    // updateProgressBar, etc.) need to be included here or in a separate file. 
    // They must be adapted to work with dynamically added elements.
    // The setupPlayButtons, setupPlayAllButton, etc. calls within 
    // initializeDynamicContentListeners assume these functions exist.

    // Placeholder for YouTube player functions - REPLACE with actual functions
    let currentPlayer = null;
    let youtubeReady = false;
    let activeTrackItem = null;
    let updateTimeInterval = null;
    let trackQueue = [];
    let currentTrackIndex = -1;
    let isPlayingAll = false;
    let switchTrackTimeout = null;
    const TRACK_PLAY_DURATION = 120000; // 2 minutes

    window.onYouTubeIframeAPIReady = function() {
        youtubeReady = true;
        console.log("YouTube API is ready");
        
        // Make sure the YT object is fully initialized
        if (!YT || !YT.Player) {
            console.error("YouTube API not properly initialized");
            setTimeout(() => {
                // Try again in a moment if YT isn't ready
                if (YT && YT.Player) {
                    console.log("YouTube API initialized on retry");
                    setupPlayButtons(document);
                }
            }, 1000);
            return;
        }
        
        // Setup event listeners for any existing play buttons
        setupPlayButtons(document);
    };

    function setupPlayButtons(container) {
        const playButtons = container.querySelectorAll('.play-button');
        playButtons.forEach(button => {
            button.addEventListener('click', function() {
                if (!youtubeReady) {
                    console.warn("YouTube API not ready yet.");
                    showError("Player is loading, please wait...");
                    return;
                }
                const trackName = decodeURIComponent(this.dataset.track);
                const trackItem = this.closest('.track-item');
                playTrack(trackName, trackItem);
            });
        });
    }
    
    function setupPlayAllButton(container) {
        const playAllBtn = container.querySelector('#play-all-btn');
        if (playAllBtn) {
             // Attach listener here instead of globally
             playAllBtn.addEventListener('click', function() {
                 if (isPlayingAll) {
                     stopPlayAll();
                 } else {
                     startPlayAll();
                 }
             });
        }
    }

    function setupSkipButton(container) {
         const skipBtn = container.querySelector('#skip-track-btn');
         if(skipBtn) {
             // Attach listener here instead of globally
            skipBtn.addEventListener('click', skipTrack);
         }
    }
    
    function setupFilterCheckbox(container) {
         const showAllMixesCheckbox = container.querySelector('#show-all-mixes');
         if (showAllMixesCheckbox) {
            showAllMixesCheckbox.addEventListener('change', function() {
                const noTracklistMixes = container.querySelectorAll('.mix-no-tracklist');
                noTracklistMixes.forEach(mix => {
                    mix.style.display = this.checked ? 'block' : 'none';
                });
            });
            // Trigger change once to apply initial state
            showAllMixesCheckbox.dispatchEvent(new Event('change')); 
        }
    }

    // Function to play a YouTube track
    function playTrack(trackName, trackItemElement) {
        console.log(`Attempting to play: ${trackName}`);
        
        // If a player is active, deactivate it
        if (activeTrackItem) {
            deactivatePlayer(activeTrackItem);
        }
        
        // Set this as the active track
        activeTrackItem = trackItemElement;
        
        // Get the required elements
        const playButton = trackItemElement.querySelector('.play-button');
        if (playButton) {
            playButton.disabled = true;
            playButton.innerHTML = '<span class="loading-icon">⏳</span> Loading...';
        }
        
        const playerContainer = trackItemElement.querySelector('.inline-player-container');
        const playerWrapper = trackItemElement.querySelector('.youtube-player-wrapper');
        
        if (!playerContainer || !playerWrapper) {
            console.error('Player container or wrapper not found');
            return;
        }
        
        // Make sure the DOM is fully prepared before proceeding
        // Find or create the necessary control elements
        const audioControls = playerContainer.querySelector('.audio-controls');
        if (!audioControls) {
            console.error('Audio controls not found');
            return;
        }
        
        let timeDisplay = audioControls.querySelector('.time-display');
        let playPauseBtn = audioControls.querySelector('.play-pause-btn');
        let youtubeLink = audioControls.querySelector('.youtube-link');
        
        // Show the player container
        playerContainer.style.display = 'block';
        
        // Search for a YouTube video related to the track
        searchYouTubeVideo(trackName)
            .then(videoId => {
                if (!videoId) {
                    console.error('No video ID found for track:', trackName);
                    deactivatePlayer(trackItemElement);
                    return;
                }
                
                // Update YouTube link
                if (youtubeLink) {
                    youtubeLink.href = `https://www.youtube.com/watch?v=${videoId}`;
                }
                
                // Reset UI controls
                if (timeDisplay) timeDisplay.textContent = '0:00';
                if (playPauseBtn) playPauseBtn.textContent = '⏸';
                
                console.log(`Creating player for video ID: ${videoId}`);
                
                // Create unique container ID
                const containerId = `yt-player-${Date.now()}`;
                playerWrapper.innerHTML = `<div id="${containerId}"></div>`;
                
                // Create the YouTube player
                currentPlayer = createPlayer(
                    containerId,
                    videoId,
                    (event) => {
                        // Player ready handler
                        console.log('Player ready');
                        if (playButton) {
                            playButton.style.display = 'none';
                        }
                        
                        // Make sure the video actually plays
                        try {
                            event.target.playVideo();
                        } catch (e) {
                            console.error('Error playing video:', e);
                        }
                        
                        // Set up time update interval
                        if (updateTimeInterval) clearInterval(updateTimeInterval);
                        updateTimeInterval = setInterval(() => {
                            if (currentPlayer && typeof currentPlayer.getCurrentTime === 'function') {
                                try {
                                    const currentTime = currentPlayer.getCurrentTime() || 0;
                                    const duration = currentPlayer.getDuration() || 0;
                                    
                                    if (duration > 0 && timeDisplay) {
                                        // Update time display if it exists
                                        const currentTimeFormatted = formatTime(currentTime);
                                        const durationFormatted = formatTime(duration);
                                        timeDisplay.textContent = `${currentTimeFormatted} / ${durationFormatted}`;
                                    }
                                } catch (err) {
                                    console.warn('Error updating time display:', err);
                                }
                            }
                        }, 1000);
                    },
                    (event) => {
                        // Player state change handler
                        console.log('Player state change:', event.data);
                        if (playPauseBtn) {
                            try {
                                if (event.data === YT.PlayerState.PLAYING) {
                                    playPauseBtn.textContent = '⏸️';
                                } else if (event.data === YT.PlayerState.PAUSED) {
                                    playPauseBtn.textContent = '▶️';
                                } else if (event.data === YT.PlayerState.ENDED) {
                                    deactivatePlayer(trackItemElement);
                                }
                            } catch (err) {
                                console.warn('Error updating player UI:', err);
                            }
                        }
                    },
                    (event) => {
                        // Player error handler
                        onPlayerError(event, playPauseBtn, timeDisplay, trackItemElement);
                    }
                );
            })
            .catch(error => {
                console.error('Error creating player:', error);
                deactivatePlayer(trackItemElement);
            });
    }
    
    // Very quick hash function - no async needed, just for consistent selection
    function generateQuickHash(str) {
        let hash = 5381;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) + hash) + str.charCodeAt(i);
        }
        return hash;
    }
    
    // List of guaranteed embeddable videos that definitely allow embedding
    const EMBEDDABLE_VIDEOS = [
        // YouTube provided samples and music that's guaranteed to work with embedding
        'M7lc1UVf-VE', 'YE7VzlLtp-4', 'jNQXAC9IVRw', '5qap5aO4i9A', 'DyDfgMOUjCI',
        'FkOt19CUC30', 'bQn35T4Aa2U', 'aGSKrC7dGcY', 'dQw4w9WgXcQ', 'J9XcFmTYUXQ',
        '5_ARibfCMhw', 'LXb3EKWsInQ', 'bM7SZ5SBzyY', 'aqz-KE-bpKQ', 'w_Ma8oQLmSM',
        'KKVEZr1LL_s', 'BJNc9j4JzSo', 'Ml9cD75OfUU', '2lAe1cqCOXo', 'P83O-N3XrJc'
    ];
    
    // Add error handling for the player
    function onPlayerError(event, playPauseBtn, timeDisplay, trackItemElement) {
        const errorCodes = {
            2: 'Invalid video ID',
            5: 'HTML5 player error',
            100: 'Video not found or removed',
            101: 'Video embedding not allowed',
            150: 'Video embedding not allowed'
        };
        
        const errorMessage = errorCodes[event.data] || `Unknown error (${event.data})`;
        console.error(`Player error: ${errorMessage}`);
        
        if (timeDisplay) {
            timeDisplay.textContent = 'Error';
        }
        if (playPauseBtn) {
            playPauseBtn.textContent = '!'; // Error symbol
        }
        
        // Try a different video immediately for any error
        if (activeTrackItem) {
            const trackBtn = activeTrackItem.querySelector('.play-button');
            if (trackBtn) {
                const trackName = decodeURIComponent(trackBtn.dataset.track);
                
                // Clear this track from cache so we get a different video next time
                if (window.videoCache) {
                    delete window.videoCache[trackName];
                }
                
                // Mark as retry attempt to get a different video
                const retryTrackName = trackName + "__retry_" + Date.now();
                trackBtn.dataset.track = encodeURIComponent(retryTrackName);
                
                // Try to play a different video immediately
                setTimeout(() => {
                    if (activeTrackItem) {
                        console.log("Retrying with a different video after error");
                        playTrack(retryTrackName, activeTrackItem);
                    }
                }, 250);
            }
        }
    }
    
    // Get a truly reliable video ID that's guaranteed to work
    function getReliableVideoId(index) {
        // These videos are absolutely guaranteed to work with embedding
        // Use YouTube's own example videos and popular content that allows embedding
        const reliableVideos = [
            'M7lc1UVf-VE',  // YouTube API test video
            'jNQXAC9IVRw',  // First YouTube video ever
            'dQw4w9WgXcQ'   // Rick Astley - most reliable fallback
        ];
        return reliableVideos[index % reliableVideos.length];
    }
    
    // Search YouTube for a video related to the track
    function searchYouTubeVideo(trackName, retryAttempt = false) {
        return new Promise((resolve) => {
            // Initialize video cache if not exists
            if (!window.videoCache) {
                window.videoCache = {};
            }
            
            // Check if we have a cached video ID for this track
            if (window.videoCache[trackName] && !retryAttempt) {
                console.log(`Using cached video ID for track ${trackName}`);
                resolve(window.videoCache[trackName]);
                return;
            }
            
            // If this is a retry, we need to pick a new video
            const isRetry = trackName.includes("__retry_");
            const cleanTrackName = isRetry ? trackName.split("__retry_")[0] : trackName;
            
            // Parse the artist and track name
            let artistName = "";
            let songTitle = cleanTrackName;
            
            if (cleanTrackName.includes(" - ")) {
                const parts = cleanTrackName.split(" - ");
                artistName = parts[0].trim();
                songTitle = parts.slice(1).join(" - ").trim();
            }
            
            // Generate hashes for artist and track
            const artistHash = Math.abs(generateQuickHash(artistName || songTitle));
            const trackHash = Math.abs(generateQuickHash(songTitle));
            
            // Select a video from our embeddable list
            let index;
            let videoId;
            
            if (isRetry) {
                // For retries, just use one of the absolutely guaranteed working videos
                // Count number of retries from the timestamp in the track name
                const retryCount = isRetry ? parseInt(trackName.split("__retry_")[1], 10) % 10 : 0;
                videoId = getReliableVideoId(retryCount);
                console.log(`Using ultra-reliable video ID ${videoId} for retry`);
            } else {
                // Normal selection based on hashes
                index = (artistHash + trackHash) % EMBEDDABLE_VIDEOS.length;
                videoId = EMBEDDABLE_VIDEOS[index];
            }
            
            console.log(`Selected video ${videoId} for track ${cleanTrackName} (${isRetry ? 'retry' : 'first attempt'})`);
            
            // Cache the result unless it's a retry
            if (!isRetry) {
                window.videoCache[trackName] = videoId;
            }
            
            resolve(videoId);
        });
    }
    
    function deactivatePlayer(trackItemElement) {
        const playerContainer = trackItemElement.querySelector('.inline-player-container');
        const playerWrapper = trackItemElement.querySelector('.youtube-player-wrapper');
        const playButton = trackItemElement.querySelector('.play-button');
        
        if (currentPlayer && typeof currentPlayer.stopVideo === 'function') {
            currentPlayer.stopVideo();
            currentPlayer.destroy(); // Clean up player instance
            console.log("Previous player stopped and destroyed");
        }
        currentPlayer = null;
        playerContainer.style.display = 'none';
        playerWrapper.innerHTML = ''; // Clear player div
        if(playButton) {
            playButton.innerHTML = '<span class="play-icon">▶</span> Play';
            playButton.disabled = false;
        }
        if (updateTimeInterval) clearInterval(updateTimeInterval);
        activeTrackItem = null;
    }
    
    // Function to create the YouTube player
    function createPlayer(containerId, videoId, onReady, onStateChange, onError) {
        console.log(`Creating YouTube player for ${containerId} with video ${videoId}`);
        
        try {
            // Create a player with the most reliable settings possible
            return new YT.Player(containerId, {
                height: '1',
                width: '1',
                videoId: videoId,
                playerVars: {
                    // Critical settings that increase success rate
                    'autoplay': 1,
                    'controls': 0,
                    'mute': 0,  // Unmuted for audio playback
                    'playsinline': 1,
                    'modestbranding': 1,
                    'rel': 0,
                    'showinfo': 0,
                    'enablejsapi': 1,
                    'origin': window.location.origin,
                    // Simplify the player as much as possible 
                    'disablekb': 1,
                    'iv_load_policy': 3,
                    'fs': 0,
                    'cc_load_policy': 0
                },
                events: {
                    'onReady': function(event) {
                        console.log('Player ready - explicitly playing');
                        // Ensure video plays when ready
                        event.target.playVideo();
                        
                        // Call the provided callback
                        if (typeof onReady === 'function') {
                            onReady(event);
                        }
                        
                        // Fallback if autoplay fails
                        setTimeout(function() {
                            if (event.target.getPlayerState() !== YT.PlayerState.PLAYING) {
                                console.log('Autoplay may have failed - trying explicit play');
                                event.target.playVideo();
                            }
                        }, 1000);
                    },
                    'onStateChange': onStateChange,
                    'onError': onError
                }
            });
        } catch (error) {
            console.error('Error creating YouTube player:', error);
            // Use a fallback approach if needed
            onError({ data: 0 });
            return null;
        }
    }
    
    // Format time in MM:SS format
    function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = Math.floor(seconds % 60);
        return `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
    }

    // --- Placeholder Play All/Skip functions ---
     function startPlayAll() {
        console.log("Starting Play All");
        const allPlayButtons = resultsContainer.querySelectorAll('.play-button');
        trackQueue = Array.from(allPlayButtons).map(btn => ({ 
            button: btn, 
            trackName: decodeURIComponent(btn.dataset.track),
            trackItem: btn.closest('.track-item')
         }));
        
        if (trackQueue.length > 0) {
            currentTrackIndex = 0;
            isPlayingAll = true;
            document.getElementById('skip-track-btn').disabled = false;
            document.getElementById('play-all-btn').textContent = 'Stop Play All'; // Change button text
            playTrackFromQueue(currentTrackIndex);
        } else {
            showError("No tracks found to play.");
        }
    }
    
    function stopPlayAll() {
         console.log("Stopping Play All");
        isPlayingAll = false;
         if (currentPlayer && typeof currentPlayer.stopVideo === 'function') {
            deactivatePlayer(activeTrackItem);
         }
         if (switchTrackTimeout) clearTimeout(switchTrackTimeout);
         document.getElementById('skip-track-btn').disabled = true;
         document.getElementById('play-all-btn').textContent = 'Play All Tracks';
         trackQueue = [];
         currentTrackIndex = -1;
    }
    
    function playTrackFromQueue(index) {
        if (index < 0 || index >= trackQueue.length || !isPlayingAll) {
             console.log("Play All finished or stopped.");
             stopPlayAll();
             return;
        }
        const item = trackQueue[index];
        console.log(`Play All: Playing track ${index + 1}/${trackQueue.length}: ${item.trackName}`);
        playTrack(item.trackName, item.trackItem);
        
        // Set timeout to automatically skip to the next track after TRACK_PLAY_DURATION
        // Clear any existing timeout first
        if (switchTrackTimeout) clearTimeout(switchTrackTimeout);
        switchTrackTimeout = setTimeout(() => {
            console.log(`Play All: Time limit reached for track ${index + 1}, skipping...`);
            skipTrack();
        }, TRACK_PLAY_DURATION);
    }

    function skipTrack() {
         if (!isPlayingAll) return;
         if (switchTrackTimeout) clearTimeout(switchTrackTimeout); // Clear timer if manually skipping
         
         currentTrackIndex++;
         if (currentTrackIndex < trackQueue.length) {
            console.log("Skipping to next track");
            playTrackFromQueue(currentTrackIndex);
         } else {
             console.log("Play All: Reached end of queue.");
             stopPlayAll();
         }
    }
    
    // Initial setup for any static listeners if needed (e.g. direct PDF form)
    // The dynamic content listeners are called after results are rendered.
});
</script>
{% endblock %} 