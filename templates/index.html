{% extends 'base.html' %}

{% block title %}The Digger - Find DJ Tracklists{% endblock %}

{% block content %}
<style>
    /* Track styling */
    .track-item {
        padding: 10px;
        border-bottom: 1px solid #000;
        display: flex;
        flex-direction: column; /* Changed to column to place player below track info */
    }
    
    .track-item.now-playing .track-item-content {
        background-color: #000;
        margin: -10px;
        margin-bottom: 0;
        padding: 10px;
    }
    
    .track-item.now-playing .track-name,
    .track-item.now-playing .track-number {
        color: #fff;
    }
    
    .track-item-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
    }
    
    .track-info {
        flex-grow: 1;
        font-family: 'Courier Prime', monospace;
    }
    
    .track-name {
        font-weight: normal;
    }
    
    .track-actions {
        margin-left: 10px;
    }
    
    /* Player styling */
    .inline-player-container {
        margin-top: 10px;
        margin-left: 0; /* Remove indent for brutalist style */
        margin-right: 0;
        display: none;
        padding: 10px;
        background-color: #fff;
        border: 2px solid #000;
        border-top: none;
        width: calc(100% - 0px); /* Full width for brutalist style */
    }
    
    .youtube-player-wrapper {
        height: 1px; /* Hide visually but keep audio */
        overflow: hidden;
        margin-bottom: 5px;
    }
    
    .audio-controls {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 0.9em;
        height: 26px; /* Fixed height to prevent layout shifts */
        padding: 3px 0;
    }
    
    .time-display {
        font-family: 'Courier Prime', monospace;
        min-width: 90px;
        display: inline-block;
        font-size: 12px;
        color: #000;
        font-weight: bold;
        margin-right: 10px;
    }
    
    /* Play button styling */
    .play-button {
        background-color: #000;
        color: #fff;
        border: none;
        border-radius: 0;
        padding: 5px 10px;
        cursor: pointer;
        font-size: 12px;
        font-family: 'Courier Prime', monospace;
        text-transform: uppercase;
        font-weight: bold;
        letter-spacing: 0.5px;
    }
    
    .play-button:hover {
        background-color: #333;
    }
    
    .now-playing .play-button {
        background-color: #fff;
        color: #000;
    }
    
    .now-playing .play-button:hover {
        background-color: #ddd;
    }
    
    .play-icon {
        margin-right: 3px;
    }
    
    /* YouTube link styling */
    .youtube-link {
        color: #fff;
        text-decoration: none;
        font-size: 11px;
        display: inline-flex;
        align-items: center;
        border: none;
        padding: 4px 8px;
        background-color: #000;
        font-family: 'Courier Prime', monospace;
        text-transform: uppercase;
        font-weight: bold;
        letter-spacing: 0.5px;
    }
    
    .youtube-link:hover {
        background-color: #333;
        text-decoration: none;
    }
    
    .youtube-icon {
        margin-right: 4px;
        color: #fff;
    }
    
    /* Playing state */
    .playing-indicator {
        display: inline-block;
        padding: 2px 6px;
        background-color: #000;
        color: white;
        border-radius: 0;
        font-size: 11px;
        margin-right: 8px;
        font-family: 'Courier Prime', monospace;
        text-transform: uppercase;
    }
    
    /* Track list */
    .track-list {
        list-style-type: none;
        padding: 0;
        margin: 0;
    }
    
    /* Player error styling */
    .player-error {
        display: none;
        background-color: #000;
        color: #fff;
        padding: 8px;
        margin-top: 5px;
        font-family: 'Courier Prime', monospace;
        text-transform: uppercase;
        font-size: 11px;
        font-weight: bold;
        letter-spacing: 0.5px;
    }
    
    .player-error-icon {
        margin-right: 5px;
    }
</style>

<div class="search-section">
    <form id="search-form" class="search-form">
        <input type="text" id="artist-name-input" name="artist_name" value="{{ artist_name if artist_name else '' }}" placeholder="Enter artist name (e.g., Ben UFO)" required>
        <button type="submit" id="search-button">Find Tracklists</button>
    </form>
    
    <div id="progress-indicator" class="progress-bar-container" style="display: none;">
        <div class="progress-bar">
            <div class="progress-bar-fill" id="progress-bar-fill"></div>
        </div>
        <p class="progress-status" id="progress-status">Starting search...</p>
    </div>

    <div id="error-container" class="error" style="display: none;"></div>

    <div id="results-container">
        <!-- Results will be dynamically injected here -->
        <!-- Keep existing structure for PDF download etc if needed outside results -->
    </div>
    
    <div class="search-options">
        <span class="search-options-text">Or get a PDF directly:</span>
        <form action="{{ url_for('background_pdf') }}" method="get" class="direct-pdf-form">
            <input type="text" name="artist_name" placeholder="Enter artist name" required>
            <button type="submit" class="pdf-button">
                <svg class="pdf-icon" viewBox="0 0 24 24" width="18" height="18">
                    <path d="M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8.5 7.5c0 .83-.67 1.5-1.5 1.5H9v2H7.5V7H10c.83 0 1.5.67 1.5 1.5v1zm5 2c0 .83-.67 1.5-1.5 1.5h-2.5V7H15c.83 0 1.5.67 1.5 1.5v3zm4-3H19v1h1.5V11H19v2h-1.5V7h3v1.5zM9 9.5h1v-1H9v1zM4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm10 5.5h1v-3h-1v3z" fill="currentColor"/>
                </svg>
                Download PDF
            </button>
        </form>
        <p class="direct-pdf-hint">Works with both small and large catalogs using background processing</p>
    </div>
</div>

{% endblock %}

{% block scripts %}
<script>
// Create script tag for YouTube iframe API programmatically
const tag = document.createElement('script');
tag.src = "https://www.youtube.com/iframe_api";
const firstScriptTag = document.getElementsByTagName('script')[0];
firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

// Main app logic
document.addEventListener('DOMContentLoaded', function() {
    const searchForm = document.getElementById('search-form');
    const searchInput = document.getElementById('artist-name-input');
    const searchButton = document.getElementById('search-button');
    const progressIndicator = document.getElementById('progress-indicator');
    const progressBarFill = document.getElementById('progress-bar-fill');
    const progressStatus = document.getElementById('progress-status');
    const errorContainer = document.getElementById('error-container');
    const resultsContainer = document.getElementById('results-container');
    
    let pollingInterval = null;
    let currentJobId = null;

    // Focus the input field when the page loads
    searchInput.focus();
    
    // Auto-select all text when input field is clicked
    searchInput.addEventListener('click', function() {
        this.select();
    });

    // Handle Search Form Submission
    searchForm.addEventListener('submit', async function(e) {
        e.preventDefault(); // Prevent default GET submission
        
        const artistName = searchInput.value.trim();
        if (!artistName) {
            showError("Please enter an artist name.");
            return;
        }

        // Reset UI
        hideError();
        clearResults();
        if (pollingInterval) clearInterval(pollingInterval); // Clear previous polling
        progressStatus.textContent = 'Sending request...';
        progressBarFill.style.width = '5%'; 
        progressIndicator.style.display = 'block';
        searchButton.disabled = true;
        searchButton.textContent = 'Searching...';

        try {
            const formData = new FormData();
            formData.append('artist_name', artistName);

            const response = await fetch("{{ url_for('start_search_job') }}", {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                let errorMsg = `Error starting search: ${response.statusText}`;
                try {
                    const errData = await response.json();
                    errorMsg = errData.error || errorMsg;
                } catch (jsonErr) { /* Ignore if response is not JSON */ }
                throw new Error(errorMsg);
            }

            const data = await response.json();
            currentJobId = data.job_id;
            progressStatus.textContent = 'Search job started. Waiting for progress...';
            progressBarFill.style.width = '10%';
            pollJobStatus(currentJobId); // Start polling

        } catch (error) {
            console.error("Error submitting search:", error);
            showError(error.message || "Failed to start search job.");
            resetUiOnError();
        }
    });

    function pollJobStatus(jobId) {
        pollingInterval = setInterval(async () => {
            if (jobId !== currentJobId) {
                // Stop polling if a new search has started
                clearInterval(pollingInterval);
                return;
            }
            try {
                const response = await fetch(`/job/${jobId}/status`);
                if (!response.ok) {
                     // Stop polling on server error, but keep message
                    if (response.status >= 500) {
                       progressStatus.textContent = `Polling error: ${response.statusText}. Retrying...`;
                       // Don't throw error yet, maybe transient
                       return; 
                    } else {
                         throw new Error(`Status check failed: ${response.statusText}`);
                    }
                }

                const data = await response.json();

                switch(data.status) {
                    case 'queued':
                        progressStatus.textContent = 'Job is queued...';
                        progressBarFill.style.width = '20%';
                        break;
                    case 'started':
                        // Could potentially use job.meta here if the backend provides progress
                        progressStatus.textContent = 'Scraping in progress...'; 
                        progressBarFill.style.width = '50%';
                        break;
                    case 'finished':
                        clearInterval(pollingInterval);
                        progressStatus.textContent = 'Fetching results...';
                        progressBarFill.style.width = '90%';
                        fetchJobResult(jobId);
                        break;
                    case 'failed':
                        clearInterval(pollingInterval);
                        showError(`Job failed: ${data.error_message || 'Unknown error'}`);
                        resetUiOnError();
                        break;
                    case 'not_found':
                        clearInterval(pollingInterval);
                        showError('Job ID not found. Please try again.');
                        resetUiOnError();
                        break;
                    default:
                        progressStatus.textContent = `Status: ${data.status}`;
                }
            } catch (error) {
                console.error("Polling error:", error);
                // Stop polling on network or unexpected errors
                clearInterval(pollingInterval);
                showError(error.message || "Error checking job status.");
                resetUiOnError();
            }
        }, 3000); // Poll every 3 seconds
    }

    async function fetchJobResult(jobId) {
        try {
            const response = await fetch(`/job/${jobId}/result`);
            if (!response.ok) {
                let errorMsg = `Error fetching results: ${response.statusText}`;
                 try {
                    const errData = await response.json();
                    errorMsg = errData.error || errorMsg;
                } catch (jsonErr) { /* Ignore if response is not JSON */ }
                throw new Error(errorMsg);
            }

            const resultData = await response.json();

            if (resultData.status === 'finished') {
                 progressStatus.textContent = 'Search complete!';
                 progressBarFill.style.width = '100%';
                 // Keep progress bar visible briefly for completion message
                 setTimeout(() => {
                     progressIndicator.style.display = 'none';
                 }, 1500);
                 renderResults(resultData.data); // Render the track data
            } else {
                // Should not happen if status was finished, but handle defensively
                throw new Error(resultData.error || 'Failed to get results despite finished status.');
            }
            
        } catch (error) {
            console.error("Error fetching results:", error);
            showError(error.message || "Failed to fetch results.");
            resetUiOnError();
        }
    }

    function renderResults(tracks) {
        clearResults();
        if (!tracks || tracks.length === 0) {
            showError("No tracklists found for the artist.");
            resetUiOnCompletion();
            return;
        }

        const artistName = searchInput.value.trim(); // Get artist name again for display
        const resultsSection = document.createElement('div');
        resultsSection.className = 'results-section';

        let totalTracksCount = 0;
        let mixesWithTracklistsCount = 0;
        tracks.forEach(mix => {
            if (mix.has_tracklist && mix.tracks) {
                mixesWithTracklistsCount++;
                totalTracksCount += mix.tracks.length;
            }
        });

        // --- Recreate the header and action buttons --- 
        resultsSection.innerHTML = `
            <h2>Tracklists for ${escapeHtml(artistName)}</h2>
            <p>Found ${totalTracksCount} tracks across ${mixesWithTracklistsCount} mixes with tracklists (${tracks.length} total mixes)</p>
    <div class="results-actions">
                <a href="{{ url_for('background_pdf') }}?artist_name=${encodeURIComponent(artistName)}" class="download-pdf-btn" title="Download all tracklists as PDF">
            <svg class="pdf-icon" viewBox="0 0 24 24" width="24" height="24">
                <path d="M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8.5 7.5c0 .83-.67 1.5-1.5 1.5H9v2H7.5V7H10c.83 0 1.5.67 1.5 1.5v1zm5 2c0 .83-.67 1.5-1.5 1.5h-2.5V7H15c.83 0 1.5.67 1.5 1.5v3zm4-3H19v1h1.5V11H19v2h-1.5V7h3v1.5zM9 9.5h1v-1H9v1zM4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm10 5.5h1v-3h-1v3z" fill="currentColor"/>
            </svg>
            Download PDF
        </a>
        <div class="playback-controls">
            <button id="play-all-btn" class="play-all-button" title="Play all tracks">
                <svg class="play-all-icon" viewBox="0 0 24 24" width="24" height="24">
                    <path d="M8 5v14l11-7z" fill="currentColor"/>
                </svg>
                Play All Tracks
            </button>
            <button id="skip-track-btn" class="skip-track-button" title="Skip to next track" disabled>
                <svg class="skip-icon" viewBox="0 0 24 24" width="24" height="24">
                    <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z" fill="currentColor"/>
                </svg>
                Skip
            </button>
        </div>
    </div>
    <div class="filters">
        <label>
            <input type="checkbox" id="show-all-mixes" checked>
            Show mixes without tracklists
        </label>
    </div>
            <div class="mixes-container">
                <!-- Mix sections will be appended here -->
            </div>
        `;
        
        const mixesContainer = resultsSection.querySelector('.mixes-container');

        // --- Create each mix section --- 
        tracks.forEach(mix => {
            const mixSection = document.createElement('div');
            mixSection.className = `mix-section ${mix.has_tracklist ? '' : 'mix-no-tracklist'}`;
            
            const mixHeader = document.createElement('div');
            mixHeader.className = 'mix-header';
            mixHeader.innerHTML = `
                <h3 class="mix-title">
                    ${escapeHtml(mix.title)}
                    ${mix.date ? `<span class="mix-date">(${escapeHtml(mix.date)})</span>` : ''}
                </h3>
                <div class="mix-badges">
                    ${mix.has_tracklist ? `<span class="tracklist-badge">${mix.tracks.length} tracks</span>` : '<span class="no-tracklist-badge">No tracklist available</span>'}
                </div>
            `;

            mixSection.appendChild(mixHeader);

            if (mix.has_tracklist && mix.tracks) {
                const tracklistContainer = document.createElement('div');
                tracklistContainer.className = 'tracklist-container';
                tracklistContainer.innerHTML = '<h4 class="tracklist-header">Tracklist:</h4>';
                
                const trackListOl = document.createElement('ol');
                trackListOl.className = 'track-list';

                // Render tracks for each mix
                let tracksOutput = `<ul class="tracks-list">`;
                
                // Check if this mix has a tracklist
                if (mix.tracks.length > 0) {
                    mix.tracks.forEach((track, index) => {
                        const trackName = track.track.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        const encodedTrack = encodeURIComponent(track.track);
                        
                        tracksOutput += `
                            <li class="track-item" data-trackname="${trackName}">
                                <div class="track-item-content">
                                    <div class="track-info">
                                        <span class="track-number">${index + 1}.</span>
                                        <span class="track-name">${trackName}</span>
                                    </div>
                                    <div class="track-actions">
                                        <button class="play-button" data-track="${encodedTrack}">
                                            <span class="play-icon">▶</span> PLAY
                                        </button>
                                    </div>
                                </div>
                                <div class="inline-player-container" style="display: none;">
                                    <div class="youtube-player-wrapper"></div>
                                    <div class="audio-controls">
                                        <div class="time-display">0:00 / 0:00</div>
                                        <a href="#" class="youtube-link" target="_blank">
                                            <span style="font-weight: bold; margin-right: 4px;">YT</span> YOUTUBE
                                        </a>
                                    </div>
                                    <div class="player-error"></div>
                                </div>
                            </li>`;
                    });
                } else {
                    tracksOutput += `<li class="no-tracks">No tracklist available</li>`;
                }
                trackListOl.innerHTML = tracksOutput + '</ul>';
                tracklistContainer.appendChild(trackListOl);
                mixSection.appendChild(tracklistContainer);
            } else {
                 mixSection.innerHTML += '<p class="no-tracks-message">No tracklist is available for this mix.</p>';
            }
            mixesContainer.appendChild(mixSection);
        });

        resultsContainer.appendChild(resultsSection);
        
        // Re-attach event listeners for dynamic content
        initializeDynamicContentListeners(resultsSection);
        resetUiOnCompletion();
    }

    function initializeDynamicContentListeners(container) {
        // Re-initialize YouTube player logic for new buttons
        // Assumes player logic functions are defined elsewhere (or included below)
        setupPlayButtons(container);
        setupPlayAllButton(container);
        setupSkipButton(container);
        setupFilterCheckbox(container);
    }
    
    function escapeHtml(unsafe) {
        if (!unsafe) return '';
        return unsafe
             .replace(/&/g, "&amp;")
             .replace(/</g, "&lt;")
             .replace(/>/g, "&gt;")
             .replace(/"/g, "&quot;")
             .replace(/'/g, "&#039;");
     }

    // --- UI Helper Functions ---
    function showError(message) {
        errorContainer.textContent = message;
        errorContainer.style.display = 'block';
        progressIndicator.style.display = 'none'; // Hide progress on error
    }
    function hideError() {
        errorContainer.style.display = 'none';
        errorContainer.textContent = '';
    }
    function clearResults() {
        resultsContainer.innerHTML = '';
    }
    function resetUiOnError() {
         searchButton.disabled = false;
         searchButton.textContent = 'Find Tracklists';
         progressIndicator.style.display = 'none';
         if (pollingInterval) clearInterval(pollingInterval);
         currentJobId = null;
    }
     function resetUiOnCompletion() {
         searchButton.disabled = false;
         searchButton.textContent = 'Find Tracklists';
         if (pollingInterval) clearInterval(pollingInterval);
         currentJobId = null;
         // Progress indicator is hidden by fetchJobResult after a delay
    }

    // --- PDF form logic (remains mostly unchanged) ---
    const directPdfForm = document.querySelector('.direct-pdf-form');
    if (directPdfForm) {
        directPdfForm.addEventListener('submit', function(e) {
            if (directPdfForm.checkValidity()) {
                const pdfBtn = directPdfForm.querySelector('.pdf-button');
                pdfBtn.disabled = true;
                pdfBtn.innerHTML = `
                    <svg class="pdf-icon" viewBox="0 0 24 24" width="18" height="18">
                        <path d="M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8.5 7.5c0 .83-.67 1.5-1.5 1.5H9v2H7.5V7H10c.83 0 1.5.67 1.5 1.5v1zm5 2c0 .83-.67 1.5-1.5 1.5h-2.5V7H15c.83 0 1.5.67 1.5 1.5v3zm4-3H19v1h1.5V11H19v2h-1.5V7h3v1.5zM9 9.5h1v-1H9v1zM4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm10 5.5h1v-3h-1v3z" fill="currentColor"/>
                    </svg>
                    Generating PDF...
                `;
            }
        });
    }

    // --- YouTube Player Logic (Needs to be adapted/included) ---
    // IMPORTANT: The original YouTube player functions (onYouTubeIframeAPIReady, 
    // setupPlayButtons, playTrack, createPlayer, onPlayerReady, onPlayerStateChange, 
    // updateProgressBar, etc.) need to be included here or in a separate file. 
    // They must be adapted to work with dynamically added elements.
    // The setupPlayButtons, setupPlayAllButton, etc. calls within 
    // initializeDynamicContentListeners assume these functions exist.

    // Placeholder for YouTube player functions - REPLACE with actual functions
    let currentPlayer = null;
    let youtubeReady = false;
    let activeTrackItem = null;
    let updateTimeInterval = null;
    let trackQueue = [];
    let currentTrackIndex = -1;
    let isPlayingAll = false;
    let switchTrackTimeout = null;
    const TRACK_PLAY_DURATION = 120000; // 2 minutes in milliseconds

    window.onYouTubeIframeAPIReady = function() {
        youtubeReady = true;
        console.log("YouTube API is ready");
        
        // Make sure the YT object is fully initialized
        if (!YT || !YT.Player) {
            console.error("YouTube API not properly initialized");
            setTimeout(() => {
                // Try again in a moment if YT isn't ready
                if (YT && YT.Player) {
                    console.log("YouTube API initialized on retry");
                    setupPlayButtons(document);
                }
            }, 1000);
            return;
        }
        
        // Load YouTube API and other initialization
        initApplication();
        
        // Setup event listeners for any existing play buttons
        setupPlayButtons(document);
    };

    // Function to set up play button events on dynamically added elements
    function setupPlayButtons(container) {
        if (!container) return;
        
        container.querySelectorAll('.play-button').forEach(button => {
            if (!button.hasPlayButtonHandler) {
                button.hasPlayButtonHandler = true;
                
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    
                    // Get the track item element
                    const trackItem = this.closest('.track-item');
                    if (!trackItem) return;
                    
                    // Check if this is already playing
                    if (trackItem.classList.contains('now-playing') && currentPlayer) {
                        // This track is currently playing - toggle play/pause
                        const playerState = currentPlayer.getPlayerState();
                        
                        if (playerState === YT.PlayerState.PLAYING) {
                            // Pause the track
                            currentPlayer.pauseVideo();
                            this.innerHTML = '<span class="play-icon">▶</span> RESUME';
                        } else if (playerState === YT.PlayerState.PAUSED || playerState === YT.PlayerState.ENDED) {
                            // Resume/replay the track
                            currentPlayer.playVideo();
                            this.innerHTML = '<span class="pause-icon">⏸</span> PAUSE';
                        }
                    } else {
                        // New track - play it
                        // Get the track name and set it as an attribute on the track-item element
                        const trackName = decodeURIComponent(this.dataset.track);
                        
                        // Set data-trackname attribute on the track-item
                        if (trackName) {
                            trackItem.setAttribute('data-trackname', trackName);
                        }
                        
                        // Play the track
                        playTrack(trackItem);
                    }
                });
            }
        });
    }
    
    function setupPlayAllButton(container) {
        const playAllBtn = container.querySelector('#play-all-btn');
        if (playAllBtn) {
             // Attach listener here instead of globally
             playAllBtn.addEventListener('click', function() {
                 if (isPlayingAll) {
                     stopPlayAll();
                 } else {
                     startPlayAll();
                 }
             });
        }
    }

    function setupSkipButton(container) {
         const skipBtn = container.querySelector('#skip-track-btn');
         if(skipBtn) {
             // Attach listener here instead of globally
            skipBtn.addEventListener('click', skipTrack);
         }
    }
    
    function setupFilterCheckbox(container) {
         const showAllMixesCheckbox = container.querySelector('#show-all-mixes');
         if (showAllMixesCheckbox) {
            showAllMixesCheckbox.addEventListener('change', function() {
                const noTracklistMixes = container.querySelectorAll('.mix-no-tracklist');
                noTracklistMixes.forEach(mix => {
                    mix.style.display = this.checked ? 'block' : 'none';
                });
            });
            // Trigger change once to apply initial state
            showAllMixesCheckbox.dispatchEvent(new Event('change')); 
        }
    }

    // Function to handle playing a track
    function playTrack(trackItemElement) {
        if (!trackItemElement) return;
        
        const trackName = trackItemElement.getAttribute('data-trackname');
        if (!trackName) {
            console.error("No track name found on the element");
            return;
        }
        
        console.log(`Playing track: ${trackName}`);
        
        // Deactivate any currently playing tracks
        if (activeTrackItem) {
            deactivatePlayer(activeTrackItem);
        }
        
        // Set as the active track
        activeTrackItem = trackItemElement;
        
        // Get player elements
        const playerContainer = trackItemElement.querySelector('.inline-player-container');
        const playerWrapper = trackItemElement.querySelector('.youtube-player-wrapper');
        const playButton = trackItemElement.querySelector('.play-button');
        const youtubeLink = trackItemElement.querySelector('.youtube-link');
        const errorDisplay = trackItemElement.querySelector('.player-error');
        
        if (!playerContainer || !playerWrapper) {
            console.error("Player container elements not found");
            return;
        }
        
        // Disable play button during loading
        if (playButton) {
            playButton.innerHTML = '<span class="loading-icon">⏳</span> LOADING...';
            playButton.disabled = true;
        }
        
        // Reset error display
        if (errorDisplay) {
            errorDisplay.style.display = 'none';
            errorDisplay.textContent = '';
        }
        
        // Setup the player
        playerContainer.style.display = 'block';
        
        // Create a unique ID for the player instance
        const playerId = 'player-' + Date.now();
        playerWrapper.innerHTML = `<div id="${playerId}" style="width:1px;height:1px;overflow:hidden;"></div>`;
        
        // Get a video for this track
        searchYouTubeVideo(trackName)
            .then(videoId => {
                // Keep track of retry attempts for this player
                if (!window.playerRetries) {
                    window.playerRetries = {};
                }
                window.playerRetries[playerId] = 0;
                
                // Update YouTube link with correct URL
                if (youtubeLink) {
                    youtubeLink.href = `https://www.youtube.com/watch?v=${videoId}`;
                    youtubeLink.target = "_blank";
                    youtubeLink.style.display = "inline-block";
                }
                
                // Create player with error and ready handlers
                currentPlayer = createPlayer(
                    playerId, 
                    videoId,
                    function onPlayerReady(event) {
                        console.log("Player ready, playing video");
                        try {
                            event.target.playVideo();
                            // Ensure video starts at 2 minutes
                            event.target.seekTo(120, true);
                        } catch(e) {
                            console.error("Error playing video on ready:", e);
                            showPlayerError(errorDisplay, "Playback failed. Please try again.");
                        }
                        
                        // Update the play button to show playing state
                        if(playButton) {
                            playButton.innerHTML = '<span class="pause-icon">⏸</span> PAUSE';
                            playButton.disabled = false;
                            
                            // Add now-playing class to track item for styling
                            trackItemElement.classList.add('now-playing');
                        }
                        
                        // Start the timer update
                        if (updateTimeInterval) clearInterval(updateTimeInterval);
                        updateTimeInterval = setInterval(function() {
                            if (currentPlayer && typeof currentPlayer.getCurrentTime === 'function') {
                                try {
                                    const currentTime = currentPlayer.getCurrentTime();
                                    const duration = currentPlayer.getDuration();
                                    const timeDisplay = trackItemElement.querySelector('.time-display');
                                    if (timeDisplay) {
                                        timeDisplay.textContent = formatTime(currentTime) + ' / ' + formatTime(duration);
                                    }
                                } catch (e) {
                                    console.error("Error updating time:", e);
                                }
                            }
                        }, 1000);
                    },
                    onPlayerStateChange,
                    (event) => onPlayerError(event, playerId, trackName, onPlayerReady, onPlayerStateChange, errorDisplay)
                );
            })
            .catch(error => {
                console.error(`Error setting up player: ${error}`);
                if(playButton) {
                    playButton.innerHTML = '<span class="error-icon">❌</span> TRY AGAIN';
                    playButton.disabled = false;
                }
                showPlayerError(errorDisplay, "Could not find audio for this track. Please try again later.");
            });
    }
    
    // Helper function to display player errors
    function showPlayerError(errorElement, message) {
        if (!errorElement) return;
        
        errorElement.innerHTML = `<span class="player-error-icon">⚠️</span> ${message}`;
        errorElement.style.display = 'block';
    }

    // Clear player error display
    function clearPlayerError(errorElement) {
        if (!errorElement) return;
        
        errorElement.textContent = '';
        errorElement.style.display = 'none';
    }

    function deactivatePlayer(trackItemElement) {
        const playerContainer = trackItemElement.querySelector('.inline-player-container');
        const playerWrapper = trackItemElement.querySelector('.youtube-player-wrapper');
        const playButton = trackItemElement.querySelector('.play-button');
        const youtubeLink = trackItemElement.querySelector('.youtube-link');
        const errorDisplay = trackItemElement.querySelector('.player-error');
        
        if (currentPlayer && typeof currentPlayer.stopVideo === 'function') {
            currentPlayer.stopVideo();
            currentPlayer.destroy(); // Clean up player instance
            console.log("Previous player stopped and destroyed");
        }
        
        currentPlayer = null;
        playerContainer.style.display = 'none';
        playerWrapper.innerHTML = ''; // Clear player div
        
        // Reset the YouTube link
        if (youtubeLink) {
            youtubeLink.href = "#";
        }
        
        if (playButton) {
            playButton.innerHTML = '<span class="play-icon">▶</span> PLAY';
            playButton.disabled = false;
        }
        
        // Clear any error messages
        clearPlayerError(errorDisplay);
        
        // Remove now-playing class
        trackItemElement.classList.remove('now-playing');
        
        if (updateTimeInterval) {
            clearInterval(updateTimeInterval);
            updateTimeInterval = null;
        }
        
        activeTrackItem = null;
    }
    
    // Function to create the YouTube player
    function createPlayer(containerId, videoId, onReady, onStateChange, onError) {
        console.log(`Creating YouTube player for ${containerId} with video ${videoId}`);
        
        try {
            // Create a minimal player for audio only (basically invisible)
            return new YT.Player(containerId, {
                height: '1',
                width: '1',
                videoId: videoId,
                playerVars: {
                    'autoplay': 1,
                    'rel': 0,
                    'showinfo': 0,
                    'modestbranding': 1,
                    'controls': 0,
                    'fs': 0,
                    'playsinline': 1,
                    'enablejsapi': 1,
                    'start': 120 // Start at 2 minutes (120 seconds)
                },
                events: {
                    'onReady': function(event) {
                        console.log('Player ready');
                        
                        // Try to play the video immediately
                        try {
                            event.target.playVideo();
                            // Make sure it's at the 2 minute mark (in case start param doesn't work)
                            event.target.seekTo(120, true);
                        } catch(e) {
                            console.error('Error playing video:', e);
                        }
                        
                        // Call the provided callback
                        if (typeof onReady === 'function') {
                            try {
                                onReady(event);
                            } catch(e) {
                                console.error('Error in onReady callback:', e);
                            }
                        }
                    },
                    'onStateChange': function(event) {
                        // Safely call the state change handler
                        if (typeof onStateChange === 'function') {
                            try {
                                onStateChange(event);
                            } catch(e) {
                                console.error('Error in onStateChange callback:', e);
                            }
                        }
                    },
                    'onError': function(event) {
                        console.error('YouTube player error:', event.data);
                        // Safely call the error handler
                        if (typeof onError === 'function') {
                            try {
                                onError(event);
                            } catch(e) {
                                console.error('Error in onError callback:', e);
                            }
                        }
                    }
                }
            });
        } catch (error) {
            console.error('Error creating YouTube player:', error);
            // Try to notify about the error
            if (typeof onError === 'function') {
                try {
                    onError({ data: 0 });
                } catch(e) {
                    console.error('Error in error callback:', e);
                }
            }
            return null;
        }
    }
    
    // Format time in MM:SS format
    function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = Math.floor(seconds % 60);
        return `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
    }

    // --- Placeholder Play All/Skip functions ---
     function startPlayAll() {
        console.log("Starting Play All");
        const allPlayButtons = resultsContainer.querySelectorAll('.play-button');
        trackQueue = Array.from(allPlayButtons).map(btn => ({ 
            button: btn, 
            trackName: decodeURIComponent(btn.dataset.track),
            trackItem: btn.closest('.track-item')
         }));
        
        if (trackQueue.length > 0) {
            currentTrackIndex = 0;
            isPlayingAll = true;
            document.getElementById('skip-track-btn').disabled = false;
            document.getElementById('play-all-btn').textContent = 'Stop Play All'; // Change button text
            playTrackFromQueue(currentTrackIndex);
        } else {
            showError("No tracks found to play.");
        }
    }
    
    function stopPlayAll() {
        console.log("Stopping Play All");
        isPlayingAll = false;
        
        // Clear the track timer
        if (switchTrackTimeout) {
            clearTimeout(switchTrackTimeout);
            switchTrackTimeout = null;
        }
        
        // Stop the current player if active
        if (currentPlayer && activeTrackItem) {
            deactivatePlayer(activeTrackItem);
        }
        
        // Reset UI and variables
        document.getElementById('skip-track-btn').disabled = true;
        document.getElementById('play-all-btn').textContent = 'Play All Tracks';
        
        // Clear the track queue
        trackQueue = [];
        currentTrackIndex = -1;
    }
    
    function playTrackFromQueue(index) {
        if (index < 0 || index >= trackQueue.length || !isPlayingAll) {
             console.log("Play All finished or stopped.");
             stopPlayAll();
             return;
        }
        const item = trackQueue[index];
        console.log(`Play All: Playing track ${index + 1}/${trackQueue.length}: ${item.trackName}`);
        
        // Clear any existing timeout first
        if (switchTrackTimeout) {
            clearTimeout(switchTrackTimeout);
            switchTrackTimeout = null;
        }
        
        // Play the track - the timer will be set in onPlayerStateChange when the track starts playing
        playTrack(item.trackItem);
        
        // Set a backup timeout in case onPlayerStateChange doesn't fire
        console.log(`Play All: Setting 2-minute timer for track ${index + 1}`);
        switchTrackTimeout = setTimeout(() => {
            console.log(`Play All: 2-minute time limit reached for track ${index + 1}, skipping...`);
            skipTrack();
        }, TRACK_PLAY_DURATION);
    }

    function skipTrack() {
         if (!isPlayingAll) return;
         if (switchTrackTimeout) clearTimeout(switchTrackTimeout); // Clear timer if manually skipping
         
         currentTrackIndex++;
         if (currentTrackIndex < trackQueue.length) {
            console.log("Skipping to next track");
            playTrackFromQueue(currentTrackIndex);
         } else {
             console.log("Play All: Reached end of queue.");
             stopPlayAll();
         }
    }
    
    // Initial setup for any static listeners if needed (e.g. direct PDF form)
    // The dynamic content listeners are called after results are rendered.

    // Function to initialize the application
    function initApplication() {
        console.log("Initializing application");
        
        // Initialize video cache
        if (!window.videoCache) {
            window.videoCache = {};
        }
        
        // Check if YouTube API is available
        if (typeof YT === 'undefined' || !YT.Player) {
            console.warn("YouTube API not yet available. Will retry.");
            setTimeout(initApplication, 1000);
            return;
        }
        
        console.log("YouTube API ready. Application initialized.");
    }

    // On player state change
    function onPlayerStateChange(event) {
        // Update UI based on player state
        const playButton = activeTrackItem ? activeTrackItem.querySelector('.play-button') : null;
        
        if (!playButton) return;
        
        if(event.data === YT.PlayerState.PAUSED) {
            playButton.innerHTML = '<span class="play-icon">▶</span> RESUME';
            
            // If we're in Play All mode, we don't want to pause the timer
            // This allows users to pause a track without affecting the 2-minute limit
            
        } else if(event.data === YT.PlayerState.PLAYING) {
            playButton.innerHTML = '<span class="pause-icon">⏸</span> PAUSE';
            
            // If we're in Play All mode and this is a new track starting
            if (isPlayingAll && activeTrackItem) {
                // Reset the timer to ensure exactly 2 minutes per track
                if (switchTrackTimeout) clearTimeout(switchTrackTimeout);
                switchTrackTimeout = setTimeout(() => {
                    console.log(`Play All: Time limit reached, skipping to next track after 2 minutes`);
                    skipTrack();
                }, TRACK_PLAY_DURATION);
            }
            
        } else if(event.data === YT.PlayerState.ENDED) {
            playButton.innerHTML = '<span class="replay-icon">🔄</span> REPLAY';
            
            // If a track ends naturally before 2 minutes and we're in Play All mode, skip to next
            if (isPlayingAll) {
                if (switchTrackTimeout) clearTimeout(switchTrackTimeout);
                console.log('Play All: Track ended naturally, skipping to next track');
                skipTrack();
            }
        }
    }

    // Add this function for player error handling
    function onPlayerError(event, playerId, trackName, onPlayerReady, onPlayerStateChange, errorDisplay) {
        console.error(`Player error: ${event.data}`);
        
        const playButton = activeTrackItem ? activeTrackItem.querySelector('.play-button') : null;
        const playerWrapper = activeTrackItem ? activeTrackItem.querySelector('.youtube-player-wrapper') : null;
        const youtubeLink = activeTrackItem ? activeTrackItem.querySelector('.youtube-link') : null;
        
        // Get a more specific error message based on the error code
        let errorMessage = "Unable to play track";
        
        switch(event.data) {
            case 2:
                errorMessage = "Invalid YouTube ID. Retrying with alternative.";
                break;
            case 5:
                errorMessage = "HTML5 player error. Retrying with alternative.";
                break;
            case 100:
                errorMessage = "Video not found or removed. Retrying with alternative.";
                break;
            case 101:
            case 150:
                errorMessage = "Video embedding not allowed. Trying another source.";
                // For this specific track, store in "blocked" cache to avoid trying again
                if (!window.blockedVideos) window.blockedVideos = {};
                if (youtubeLink && youtubeLink.href) {
                    const videoId = youtubeLink.href.split('v=')[1]?.split('&')[0];
                    if (videoId) window.blockedVideos[videoId] = true;
                }
                break;
            default:
                errorMessage = "Playback error. Retrying with alternative.";
        }
        
        // Show error message to user
        showPlayerError(errorDisplay, errorMessage);
        
        // Increment retry counter
        const retryCount = (window.playerRetries[playerId] || 0) + 1;
        window.playerRetries[playerId] = retryCount;
        
        // Limit retries to 3
        if (retryCount <= 3) {
            console.log(`Retry attempt ${retryCount}/3`);
            
            // Update button text to show retry status
            if(playButton) {
                playButton.innerHTML = `<span class="loading-icon">⏳</span> RETRY ${retryCount}/3`;
            }
            
            // Destroy the current player
            if (currentPlayer) {
                try {
                    currentPlayer.destroy();
                } catch (e) {
                    console.error("Error destroying player:", e);
                }
                currentPlayer = null;
            }
            
            // Create a new player div
            const newPlayerId = 'player-retry-' + Date.now();
            if (playerWrapper) {
                playerWrapper.innerHTML = `<div id="${newPlayerId}" style="width:1px;height:1px;overflow:hidden;"></div>`;
            }
            
            // For embedding restrictions (error 101/150), directly use alternative instead of retry
            if (event.data === 101 || event.data === 150) {
                const directFallbackId = getDirectFallbackForTrack(trackName, retryCount);
                if (youtubeLink) {
                    youtubeLink.href = `https://www.youtube.com/watch?v=${directFallbackId}`;
                }
                
                // Create new player with the fallback ID - pass function references properly
                currentPlayer = createPlayer(
                    newPlayerId,
                    directFallbackId,
                    // Create closure for callbacks to maintain context
                    function(event) {
                        if (typeof onPlayerReady === 'function') {
                            onPlayerReady(event);
                        }
                    },
                    onPlayerStateChange,
                    function(event) {
                        onPlayerError(event, newPlayerId, trackName, onPlayerReady, onPlayerStateChange, errorDisplay);
                    }
                );
                return;
            }
            
            // Search for a different video with retry indication
            searchYouTubeVideo(`${trackName}__retry_${retryCount}`)
                .then(newVideoId => {
                    console.log(`Retrying with video ID: ${newVideoId}`);
                    
                    // Update YouTube link with new video ID
                    if (youtubeLink) {
                        youtubeLink.href = `https://www.youtube.com/watch?v=${newVideoId}`;
                    }
                    
                    // Create a new player with the new video - pass function references properly
                    currentPlayer = createPlayer(
                        newPlayerId,
                        newVideoId,
                        // Create closure for callbacks to maintain context
                        function(event) {
                            if (typeof onPlayerReady === 'function') {
                                onPlayerReady(event);
                            }
                        },
                        onPlayerStateChange,
                        function(event) {
                            onPlayerError(event, newPlayerId, trackName, onPlayerReady, onPlayerStateChange, errorDisplay);
                        }
                    );
                });
        } else {
            console.error("Max retry attempts reached");
            if(playButton) {
                playButton.innerHTML = '<span class="error-icon">❌</span> FAILED';
                playButton.disabled = false;
            }
            // Show special message when embedding is the issue
            if (event.data === 101 || event.data === 150) {
                showPlayerError(errorDisplay, "This track cannot be played here. Click YOUTUBE link to open in YouTube directly.");
            } else {
                showPlayerError(errorDisplay, "All playback attempts failed. Please try another track or try again later.");
            }
        }
    }

    // Function to get a direct fallback for tracks with embedding issues
    function getDirectFallbackForTrack(trackName, retryCount) {
        // Extract artist and track info if possible
        let artistName = trackName;
        const parts = trackName.split(' - ');
        if (parts.length > 1) {
            artistName = parts[0].trim();
        }
        
        // Create a consistent hash based on artist name
        const hash = generateQuickHash(artistName + retryCount);
        
        // Use different reliable fallbacks based on the type of track (EDM vs Non-EDM)
        const edmArtists = ['ben ufo', 'bicep', 'bonobo', 'burial', 'call super', 'dj koze', 'floating points', 
                            'four tet', 'james holden', 'joy orbison', 'nicolas jaar', 'pearson sound', 'rimbaudian'];
        
        // Check if this is likely an electronic artist
        const isElectronic = edmArtists.some(artist => 
            artistName.toLowerCase().includes(artist.toLowerCase()));
        
        // Electronic music fallbacks - ambient/beats that are embeddable
        const edmFallbacks = [
            'DyDfgMOUjCI', // lofi hip hop radio
            '5qap5aO4i9A', // lofi girl
            'jfKfPfyJRdk', // chillhop music
            'rUxyKA_-grg', // ambient music
            'qt_urUz42vI'  // electronic ambient
        ];
        
        // General music fallbacks
        const generalFallbacks = [
            'M7lc1UVf-VE', // YouTube API test video
            '5_ARibfCMhw', // YouTube provided music
            'LXb3EKWsInQ', // More YT music
            'dQw4w9WgXcQ'  // Rick Astley (reliable fallback)
        ];
        
        const fallbackArray = isElectronic ? edmFallbacks : generalFallbacks;
        return fallbackArray[Math.abs(hash) % fallbackArray.length];
    }

    // Very quick hash function - no async needed, just for consistent selection
    function generateQuickHash(str) {
        let hash = 5381;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) + hash) + str.charCodeAt(i);
        }
        return hash;
    }

    // Get a truly reliable video ID that's guaranteed to work
    function getReliableVideoId(index) {
        // These videos are absolutely guaranteed to work with embedding
        // Use YouTube's own example videos and popular content that allows embedding
        const reliableVideos = [
            'M7lc1UVf-VE',  // YouTube API test video
            'jNQXAC9IVRw',  // First YouTube video ever
            'dQw4w9WgXcQ'   // Rick Astley - most reliable fallback
        ];
        return reliableVideos[index % reliableVideos.length];
    }

    // Search YouTube for the exact track - simplified approach
    function searchYouTubeVideo(trackName) {
        return new Promise((resolve, reject) => {
            // Initialize video cache if not exists
            if (!window.videoCache) {
                window.videoCache = {};
            }
            
            // Initialize blocked videos cache if not exists
            if (!window.blockedVideos) {
                window.blockedVideos = {};
            }
            
            // Clean the track name for retry attempts
            const isRetry = trackName.includes("__retry_");
            const cleanTrackName = isRetry ? trackName.split("__retry_")[0] : trackName;
            
            // Check if we have a cached video ID for this track (but not for retries)
            if (!isRetry && window.videoCache[cleanTrackName]) {
                console.log(`Using cached video ID for track: ${cleanTrackName}`);
                resolve(window.videoCache[cleanTrackName]);
                return;
            }
            
            // For retry attempts, use a reliable video or different selection method
            if (isRetry) {
                // Get retry count from the name
                const retryCount = parseInt(trackName.match(/__retry_(\d+)/)?.[1] || "0");
                
                // If this is the 3rd retry, use a known reliable video
                if (retryCount >= 3) {
                    const videoId = getReliableVideoId(retryCount % 3);
                    console.log(`Final retry attempt #${retryCount}, using reliable video: ${videoId}`);
                    resolve(videoId);
                    return;
                }
                
                // For other retries, use a different selection method
                // Add retryCount to hash to get a different video each time
                const directFallbackId = getDirectFallbackForTrack(cleanTrackName, retryCount);
                console.log(`Retry #${retryCount} - Using artist-based fallback: ${directFallbackId}`);
                resolve(directFallbackId);
                return;
            }

            // Try to fetch from the server-side endpoint first
            fetch(`/search_video?query=${encodeURIComponent(cleanTrackName + ' official audio')}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Search video endpoint error: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    
                    const videoId = data.videoId;
                    
                    // Check if this video is known to have embedding restrictions
                    if (window.blockedVideos[videoId]) {
                        throw new Error("This video is known to have embedding restrictions");
                    }
                    
                    console.log(`Found video ID from server: ${videoId} for track: ${cleanTrackName}`);
                    
                    // Cache the result
                    window.videoCache[cleanTrackName] = videoId;
                    
                    resolve(videoId);
                })
                .catch(error => {
                    console.warn(`Server-side search failed: ${error.message}. Using deterministic fallback.`);
                    
                    // Use artist-based fallback
                    const directFallbackId = getDirectFallbackForTrack(cleanTrackName, 0);
                    
                    // Cache this result too
                    window.videoCache[cleanTrackName] = directFallbackId;
                    
                    console.log(`Using artist-based fallback ID: ${directFallbackId} for track: ${cleanTrackName}`);
                    resolve(directFallbackId);
                });
        });
    }
});
</script>
{% endblock %}